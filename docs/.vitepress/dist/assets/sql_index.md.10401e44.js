import{_ as a,y as e,x as s,W as n}from"./plugin-vue_export-helper.86aaabad.js";var t="data:image/png;base64,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",o="data:image/png;base64,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",l="/assets/3.ed4ab191.png",p="/assets/4.edcb4baf.png",i="/assets/5.ae545be9.png",r="/assets/7.633ebd15.png",c="/assets/14.48cc885e.png",u="/assets/8.313400d6.png",d="/assets/9.22822032.png",h="/assets/10.0abbd516.png",m="/assets/7.bb092154.png",k="/assets/8.bc8eafcc.png",y="/assets/13.f09cfd17.png",f="/assets/14.d2f09e93.png",b="/assets/15.f08790be.png",g="/assets/16.456b5a7a.png",w="/assets/17.ab4b77f0.png",v="/assets/19.ce35d967.png",E="/assets/20.33990961.png",T="/assets/18.54636322.png",A="/assets/21.5f10cbd9.png",O="/assets/22.6eed6e9a.png",N="/assets/23.91d80139.png",q="/assets/24.e07dc01b.png",S="/assets/25.b72bf6a7.png",R="/assets/26.2d81a93c.png";const B='{"title":"SQL AND RELATIONAL DATABASES","description":"","frontmatter":{},"headers":[{"level":3,"title":"Who names the database tables?","slug":"who-names-the-database-tables"},{"level":3,"title":"How to pick the table names and what becomes a table and what becomes a column of a table?","slug":"how-to-pick-the-table-names-and-what-becomes-a-table-and-what-becomes-a-column-of-a-table"},{"level":3,"title":"How to know what info can be saved into one table and what into a separate table?","slug":"how-to-know-what-info-can-be-saved-into-one-table-and-what-into-a-separate-table"},{"level":2,"title":"MySQL / MariaDB","slug":"mysql-mariadb"},{"level":2,"title":"SQL","slug":"sql"},{"level":3,"title":"COMMANDS","slug":"commands"},{"level":3,"title":"SELECT","slug":"select"},{"level":3,"title":"JOINS","slug":"joins"},{"level":3,"title":"EXCERCISE #1","slug":"excercise-1"},{"level":3,"title":"AGGREGATE FUNCTIONS","slug":"aggregate-functions"},{"level":3,"title":"SCALAR FUNCTIONS","slug":"scalar-functions"},{"level":3,"title":"ORDER BY","slug":"order-by"},{"level":3,"title":"INSERT","slug":"insert"},{"level":3,"title":"UPDATE","slug":"update"},{"level":3,"title":"DELETE","slug":"delete"},{"level":3,"title":"EXCERCISE #2","slug":"excercise-2"}],"relativePath":"sql/index.md","lastUpdated":1696665283300}',I={},L=n('<h1 id="sql-and-relational-databases" tabindex="-1">SQL AND RELATIONAL DATABASES <a class="header-anchor" href="#sql-and-relational-databases" aria-hidden="true">#</a></h1><p>In 1970 a computer scientist from IBM published a paper about relational model that introduced a new way of modeling data storages. It was about cross-linked tables of data. Tables would consist of rows and columns.</p><p>Think of a database as an Excel file and each of the sheets in that file as a database table</p><p><img src="'+t+'" alt="sql"></p><p><i><small>Example of a list of users in an excel sheet</small></i></p><p>Much like an Excel sheet contains rows and columns, a database table too contains rows and columns</p><p><img src="'+o+'" alt="sql"></p><p><i><small>Same kind of an example in a database table</small></i></p><p>With the exception that in an Excel sheet you can basically store what ever kind of data (numbers, strings, etc.) but the database table&#39;s columns are strictly structured and each column has to have a name, data type (integer, string, boolean etc.) and other constraints</p><p>Here in a database table the id cannot be a random string of characters because the column type is marked as INT (11) which is a 11 numbers long (max) integer</p><p><img src="'+l+'" alt="sql"></p><div class="info custom-block"><p class="custom-block-title">Datatypes and constraints</p><p>We will learn more about different datatypes and column constrains further down the road</p></div><p>Here in the example image above we have a relational database table called users. There are three columns in the table called (id, username and role)</p><h3 id="who-names-the-database-tables" tabindex="-1">Who names the database tables? <a class="header-anchor" href="#who-names-the-database-tables" aria-hidden="true">#</a></h3><p>it&#39;s the designers / developers responsibility</p><h3 id="how-to-pick-the-table-names-and-what-becomes-a-table-and-what-becomes-a-column-of-a-table" tabindex="-1">How to pick the table names and what becomes a table and what becomes a column of a table? <a class="header-anchor" href="#how-to-pick-the-table-names-and-what-becomes-a-table-and-what-becomes-a-column-of-a-table" aria-hidden="true">#</a></h3><p>There&#39;s not a definitive answer to this question. Short answer is it depends on the business requirements. Longer answer: When somebody asks you what the application, you are designing, is supposed to be doing, if you write your answer down and pick up the nouns they (the nouns) are either tables or columns in a table. The verbs are the actions (methods).</p><p><i>Verbs are not important at the point when you are thinking of a database design. Consentrate on the nouns for now</i></p><div class="info custom-block"><p class="custom-block-title">For Example</p><p><i>&quot;Users login to the system using username and password. Other info saved about each user are firstname, lastname and email&quot;</i></p></div><p>In the example above the nouns are <i>User</i>, <i>username</i>, <i>password</i>, <i>firstname</i>, <i>lastname</i> and <i>email</i></p><p>There users is the name of the table and other nouns are all features of a user so they are the columns of the table.</p><h3 id="how-to-know-what-info-can-be-saved-into-one-table-and-what-into-a-separate-table" tabindex="-1">How to know what info can be saved into one table and what into a separate table? <a class="header-anchor" href="#how-to-know-what-info-can-be-saved-into-one-table-and-what-into-a-separate-table" aria-hidden="true">#</a></h3><p>Well this too is one of those things that depend on the requirements but a rule of thumb is that <strong>always create a new table for different kind of data.</strong> For example user&#39;s social security number is strongly descriptive data of a certain user so it can be a column of the users table</p><p>But on the other hand user&#39;s address is something that should be saved into a separate table...Address is a feature of a house rather than of a user.</p><p>It&#39;s true that each user has an address but it&#39;s not a strong relation (as social security number is) but rather a weak relation and thus should be stored in a separate table.</p><div class="info custom-block"><p class="custom-block-title">Weak Relation?</p><p>Weak relation, like between a user and user&#39;s addreess is something where the one can exist without the other. For example a user can live without an address and the address doesn&#39;t cease to exist if the user dies.</p></div><p><img src="'+p+'" alt="sql"></p><p><small><i>As stated in the relational model design paper, a relational database is a collection of inter-linked tables</i></small></p><p><strong>There are actually certain rules regarding database design and how to structure and group data. That part of the design flow is called normalization, but more on that later</strong></p><p>Relational database design patterns and their rules are quite absract to start from, it&#39;s easier to start with SQL language</p><div class="tip custom-block"><p class="custom-block-title">Remember this</p><p>a relational database is a collection of inter-linked tables. A table contains columns. A column has a fixed data type. If its datatype is string you cannot insert an integer value into it.</p></div><h2 id="mysql-mariadb" tabindex="-1">MySQL / MariaDB <a class="header-anchor" href="#mysql-mariadb" aria-hidden="true">#</a></h2><ul><li><p>MySQL is a relational database system that is both GPL-licensed and commerially licensed. Originally developed by a finnish Michael &quot;Monty&quot; Widenius and a swedish David Axmark</p></li><li><p>First version published in 1996 and is still actively maintained and developed.</p></li><li><p>Is owned by Oracle nowadays</p></li><li><p>MariaDB was published when Oracle bought MySQL. MariaDB is based on the open source version of MySQL</p></li><li><p>MariaDB has the same developer as the original MySQL had and thus it is supposed to be a &#39;drop-in&#39; replacement for MySQL</p></li></ul><h2 id="sql" tabindex="-1">SQL <a class="header-anchor" href="#sql" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">Before you start learning SQL</p><ol><li>Install <a href="/softwares/#wampserver">WampServer</a></li><li>Go to Moodle, open Git repository link and download tiedonhallinta_harjoitus.sql file</li><li>Import SQL file using PHPMyadmin <ul><li>we will go thru all of this together</li></ul></li></ol></div><p>Structured Query Language is the language that relational database management systems understand. It was ISO standardized in 1986. Different manufactures, like Oracle and Microsoft spice-up their own products by adding non-standardized features into them but having been standardized nearly 40 years ago is advantageous compared to multiple NoSQL products on the market.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>It&#39;s like speaking slightly different dialects of the same language</p></div><p>It&#39;s understandable that SQL as a highly structured language isn&#39;t suitable for different modern use cases and there&#39;s a reason why NoSQL choices are ever more popular but if you have a problem with your SQL query, I can guarantee you can find the answer on the internet.</p><h3 id="commands" tabindex="-1">COMMANDS <a class="header-anchor" href="#commands" aria-hidden="true">#</a></h3><h4 id="dcl-data-control-language" tabindex="-1">DCL (Data Control Language) <a class="header-anchor" href="#dcl-data-control-language" aria-hidden="true">#</a></h4><ul><li>grant <ul><li>used to grant privileges to users for databases</li></ul></li><li>revoke <ul><li>used to revoke those privileges</li></ul></li></ul><h4 id="ddl-data-definition-language" tabindex="-1">DDL (Data Definition Language) <a class="header-anchor" href="#ddl-data-definition-language" aria-hidden="true">#</a></h4><ul><li>create <ul><li>to create databases, tables views, etc.</li></ul></li><li>drop <ul><li>to delete databases, tables vies, etc.</li></ul></li><li>rename <ul><li>to rename a table or a column of a table</li></ul></li><li>truncate <ul><li>like delete but deletes all the contents without deleting the datbase / table itself</li></ul></li></ul><h4 id="tcl-transaction-control-language" tabindex="-1">TCL (Transaction Control Language) <a class="header-anchor" href="#tcl-transaction-control-language" aria-hidden="true">#</a></h4><ul><li>commit <ul><li>to commit executed changes into a database table You can for example insert multiple rows in a table and then commit all of them atomically so that all 4 rows get added at once</li></ul></li><li>rollback <ul><li>the opposite of commit: so if one those 4 inserts fail you can rollback all of them. So either all succeed or all fail</li></ul></li></ul><h4 id="dql-data-query-language" tabindex="-1">DQL (Data Query Language) <a class="header-anchor" href="#dql-data-query-language" aria-hidden="true">#</a></h4><ul><li>select <ul><li>most used command. Used to query data from the database</li></ul></li></ul><h4 id="dml" tabindex="-1">DML <a class="header-anchor" href="#dml" aria-hidden="true">#</a></h4><ul><li>insert <ul><li>can be used to insert a new row into a database table</li></ul></li><li>update <ul><li>can be used to update an existing row in a database table</li></ul></li><li>delete <ul><li>can be used to remove row(s) from a database table</li></ul></li></ul><h3 id="select" tabindex="-1">SELECT <a class="header-anchor" href="#select" aria-hidden="true">#</a></h3><p>SELECT command is used to fetch data from database table(s)</p><p><img src="'+i+`" alt="sql"></p><div class="language-sql"><pre><code>
<span class="token comment">-- if there are a lot columns and </span>
<span class="token comment">-- you want to fetch them all </span>
<span class="token comment">-- you can use *</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>

</code></pre></div><p>The above query fetches all rows from users table. SQL language doesn&#39;t have a separate command for fetching only one row (or X rows for that matter). That&#39;s what LIMIT is for</p><h4 id="limit" tabindex="-1">LIMIT <a class="header-anchor" href="#limit" aria-hidden="true">#</a></h4><p>Limit is a handy command to limit the number of rows fetched by the query. It can for example be used for pagination.</p><p>Limit consists of two different variables OFFSET AND ROWCOUNT</p><p>but OFFSET can be omitted. If it&#39;s omitted it&#39;s default value is 0</p><div class="language-sql"><pre><code>
<span class="token comment">-- this query fetches only one row from the users table</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- it&#39;s same as this</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- the query below fetches 10 rows jumping over the first 10 rows. </span>
<span class="token comment">-- Think of it as the second page of users where there is ten users </span>
<span class="token comment">-- / page</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>



</code></pre></div><h4 id="where" tabindex="-1">WHERE <a class="header-anchor" href="#where" aria-hidden="true">#</a></h4><p>Using <i>WHERE</i> keyword you can filter the search result. You can use table columns as filtering conditions</p><div class="language-sql"><pre><code><span class="token comment">-- this query fetches the user whose id column&#39;s</span>
<span class="token comment">-- value is 1</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

</code></pre></div><div class="info custom-block"><p class="custom-block-title">What is that id column</p><p>In transactional databases it&#39;s normal to use an integer column as a so called primary key column. Primary key is a unique identifier with the help of which rows with same kind of data can uniquely be identified.</p><p>For example if you have two customers with exactly same first and lastnames, the id column might be the only column separating these two customers</p><p>It has no business value but it&#39;s there to ensure data integrity</p></div><div class="language-sql"><pre><code><span class="token comment">-- this query fetches all users whose first_name column value is &#39;juhani&#39;</span>

<span class="token comment">-- notice that in SQL strings are in single quotes</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">=</span> <span class="token string">&#39;Juhani&#39;</span><span class="token punctuation">;</span>

</code></pre></div><h4 id="and-and-or" tabindex="-1">AND and OR <a class="header-anchor" href="#and-and-or" aria-hidden="true">#</a></h4><p>The conditons in WHERE clause can also be combined using AND / OR</p><div class="language-sql"><pre><code><span class="token comment">-- Let&#39;s fetch all the users whose firstname is either </span>
<span class="token comment">-- Juhani or Matt</span>

<span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> last_name <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">=</span> <span class="token string">&#39;Juhani&#39;</span> <span class="token operator">OR</span> first_name <span class="token operator">=</span> <span class="token string">&#39;Matt&#39;</span><span class="token punctuation">;</span>

</code></pre></div><div class="language-sql"><pre><code>
<span class="token comment">-- let&#39;s fetch all the users whose firstname is Jack</span>
<span class="token comment">-- and lastname is Black</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">=</span> <span class="token string">&#39;Jack&#39;</span> <span class="token operator">AND</span> last_name <span class="token operator">=</span> <span class="token string">&#39;Black&#39;</span><span class="token punctuation">;</span>

</code></pre></div><div class="info custom-block"><p class="custom-block-title">Brackets and conditions</p><p>You can change order or execution using brackets.</p></div><div class="tip custom-block"><p class="custom-block-title">Before the next step</p><p>Remember to start up WampServer and go to PhpMyAdmin. The easiest way to open PhpMyAdmin is to click the green Wamp Server icon and choose PhpMyAdmin from the popup menu</p></div><div class="tip custom-block"><p class="custom-block-title">We were supposed to go trough this togeter in the class</p><p>But since I&#39;m sick again, here are instructions for you</p><p>Open PhpMyAdmin and tiedonhallinta_harjoitus database. If you don&#39;t have that database yet, read instructions in this page: <a href="https://help.one.com/hc/en-us/articles/115005588189-How-do-I-import-a-database-to-phpMyAdmin-" target="_blank" rel="noopener noreferrer">https://help.one.com/hc/en-us/articles/115005588189-How-do-I-import-a-database-to-phpMyAdmin-</a> to import</p><p>You can skip straight to step #4 because the database will be created during the import automatically</p></div><p>Let&#39;s execute a couple of queries in the tiedonhallinta_harjoitus database</p><div class="language-sql"><pre><code><span class="token comment">-- example 1.</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span> <span class="token operator">OR</span> last_name <span class="token operator">=</span> <span class="token string">&#39;kuru&#39;</span>

</code></pre></div><p>Keep in mind that your result might differ from the one in the picture below</p><p><img src="`+r+`" alt="sql"></p><p>But all of them have either first_name of Juhani or last_name of Kuru</p><div class="language-sql"><pre><code><span class="token comment">-- example 2</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span> <span class="token operator">OR</span> last_name <span class="token operator">=</span> <span class="token string">&#39;kuru&#39;</span> <span class="token operator">AND</span> department_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

</code></pre></div><p><img src="`+c+`" alt="sql"></p><p>If you look closely the rows missing from the second result set are the rows with ids: 19, 37, 48 and 50. What is different with these rows getting them excluded from the result set?</p><table><thead><tr><th>Id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>reason</th></tr></thead><tbody><tr><td>19</td><td>seija</td><td>kuru</td><td>3</td><td>first name isn&#39;t juhani and even if lastname is kuru the department isn&#39;t 2</td></tr><tr><td>37</td><td>eija</td><td>kuru</td><td>4</td><td>first name isn&#39;t juhani and even if lastname is kuru the department isn&#39;t 2</td></tr><tr><td>48</td><td>toni</td><td>kuru</td><td>3</td><td>first name isn&#39;t juhani and even if lastname is kuru the department isn&#39;t 2</td></tr></tbody></table><div class="language-sql"><pre><code><span class="token comment">-- example 3</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span> <span class="token operator">OR</span> last_name <span class="token operator">=</span> <span class="token string">&#39;kuru&#39;</span><span class="token punctuation">)</span> <span class="token operator">AND</span> department_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

</code></pre></div><p>No with the 3rd example query the result set contains only users with department_id 2. Using brackets in a query has an effect on the order or execution</p><h4 id="comparing-values" tabindex="-1">COMPARING VALUES <a class="header-anchor" href="#comparing-values" aria-hidden="true">#</a></h4><ul><li>= (equals) <ul><li>note that in many programming languages one equal sign is used to instantiate a variable or setting a new value into it and you need to use two equal signs when comparing two values but in SQL only one equal sign is enough for comparison</li></ul></li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>&lt;&gt; OR != (not equals)</li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">&lt;&gt;</span> <span class="token string">&#39;juhani&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">!=</span> <span class="token string">&#39;juhani&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>greater than (&gt;)</li><li>greater than or equals (&gt;? )</li><li>less than (&lt;)</li><li>less than or equals (&lt;=)</li><li>&lt;= (less than or equals)</li><li>BETWEEN AND</li></ul><div class="language-sql"><pre><code>
<span class="token comment">-- let&#39;s fetch all the employees whose salary is 3000 or more and 5000 or less </span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> salary <span class="token operator">BETWEEN</span> <span class="token number">3000</span> <span class="token operator">AND</span> <span class="token number">5000</span>

<span class="token comment">-- is the same as</span>

 <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> salary <span class="token operator">&gt;=</span> <span class="token number">3000</span> <span class="token operator">AND</span> salary <span class="token operator">&lt;=</span> <span class="token number">5000</span>

</code></pre></div><ul><li>IN <ul><li>NOT IN flips the condition</li></ul></li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- is the same as</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">OR</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">-- and </span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- is the same as </span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">&lt;&gt;</span> <span class="token number">3</span> <span class="token operator">AND</span> id <span class="token operator">&lt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>

</code></pre></div><ul><li>IS NULL <ul><li>IS NOT NULL flips the condition</li><li>by default all the columns in any relational database table are required, but it&#39;s common to have optional nullable columns. NULL values / Nullable columns are common when the value in a column is missing (optional) or is unkown (to be updated in the future if ever)</li><li>IS NULL can be used to check if a value in a column is missing or not</li></ul></li></ul><p>Let&#39;s say that you are developing an app where you want to keep track whether your users are married, single, divorced or not. For this you have a table called <i>profile_info</i> and in there you have a column named <i>marital_status</i></p><div class="language-sql"><pre><code><span class="token comment">-- we haven&#39;t taken a look into aggregate functions yet, but COUNT is one of those and it&#39;s job is to count the number of rows returned in the result set</span>
<span class="token comment">-- the query below counts the number of users who didn&#39;t reveal their marital_status</span>

<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> profile_info <span class="token keyword">WHERE</span> marital_status <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>

<span class="token comment">-- this query on the other hand counts the number of users who have told their status</span>

<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> profile_info <span class="token keyword">WHERE</span> marital_status <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>

<span class="token comment">-- keep in mind that the second query counts all the rows where marital_status is something else than NULL so with this you cannot know whether they are divorced, single or married</span>

</code></pre></div><h4 id="fuzzy-search" tabindex="-1">FUZZY SEARCH <a class="header-anchor" href="#fuzzy-search" aria-hidden="true">#</a></h4><ul><li><p>LIKE %</p><ul><li>LIKE combined with % sign makes a fuzzy search</li><li>for example the query condition matches all the rows whose first_name begins with the letter <i>j</i> and the rest of the word is anything</li></ul></li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">LIKE</span> <span class="token string">&#39;j%&#39;</span><span class="token punctuation">;</span>

</code></pre></div><ul><li>the query below matches all the rows whose first_name contains j anywhere in the word</li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">LIKE</span> <span class="token string">&#39;%j%&#39;</span><span class="token punctuation">;</span>

</code></pre></div><ul><li>the query below matches all the rows whose first_name ends with a</li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> first_name <span class="token operator">LIKE</span> <span class="token string">&#39;%a&#39;</span><span class="token punctuation">;</span>

</code></pre></div><p>_ (UNDERSCORE)</p><p>With underscore you can specify the number of characters that can be anything</p><ul><li>the query below fetches all the rows whose last_name contains four letters ending with uru</li></ul><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> last_name <span class="token operator">=</span> _uru<span class="token punctuation">;</span>
</code></pre></div><p>Note that when using underscores the number of underscores used in the query is significant (i.e makes a difference). Each underscore repsresent one letter</p><h3 id="joins" tabindex="-1">JOINS <a class="header-anchor" href="#joins" aria-hidden="true">#</a></h3><p>Thus far we&#39;ve only executed queries on a single database table. But according to the rules of normalization (more on this later) it&#39;s not recommended to save unrelated data into one single database table. Thus databases can consist of various different tables that are linked together. When <i>SELECT</i>ing data from these interlinked tables <i>JOIN</i>s must be used (*</p><div class="info custom-block"><p class="custom-block-title">(*</p><p>This applies when you need to fetch data from multiple tables with a single query. Nothing prevents you from using different queries for each table but that&#39;s not that efficient. This is why we need joins.</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>download blog.sql file from material repository and import it using PhpMyAdmin</p></div><h4 id="primary-key" tabindex="-1">PRIMARY KEY <a class="header-anchor" href="#primary-key" aria-hidden="true">#</a></h4><p>Primary Key is a special column in a database table. Its purpose is to uniquely identify each row in a database table.</p><p>Let&#39;s assume you are developing an app and you store the customers in a database table called <i>customers</i> As your customer base grows it&#39;s likely that you at some point have two different customers with the same name. Given that you only store first_name and last_name of your customers, there are now two identical rows. To be able to tell the difference between these two rows, you can add a unique, <b>auto increment</b> primary key field into the table. Now, even with these two customers every row is unique.</p><div class="tip custom-block"><p class="custom-block-title">AUTO INCREMENT?</p><p>when creating a primary key column, you can give it an auto increment constraint. Auto increment column&#39;s value increases by one automatically and it&#39;s all taken care of by the database management system</p></div><p><img src="`+u+'" alt="sql"></p><p><small><i>example of a id primary key column</i></small></p><div class="info custom-block"><p class="custom-block-title">is using auto increment mandatory for primary keys?</p><p>No it&#39;s not. Basically any unique column (only one value in each table) can be a valid primary key. For example social security number is an example of a valid primary key column value. If two people could have the same social security number, that would be interesting.</p><p>If SSN is a valid primary key, couldn&#39;t then for example email too be a primary key column, it&#39;s unique isn&#39;t it? Yeah, technically email can be a primary key value, but one advantage of using auto increment primary key column value is that it never changes. Email can change and when that happens all references have to updated too. Auto increment primary key will never change.</p></div><h4 id="foreign-key" tabindex="-1">FOREIGN KEY <a class="header-anchor" href="#foreign-key" aria-hidden="true">#</a></h4><p>Foreign key columns are references to some other table&#39;s primary keys</p><p><img src="'+d+'" alt="sql"></p><p><small><i>example of a user_id foreign key column and id primary key column</i></small></p><p>In the above picture there are two different tables. The one on the left is called <i>todo_items</i> and the other is <i>users</i></p><p><i>todo_items</i> table has a column called <i>user_id</i> this is a reference (foreign key) to the <i>users</i> table&#39;s id primary key column.</p><p><img src="'+h+'" alt="sql"></p><p><small><i>The same primary key - foreign key relation depicted in a designer view</i></small></p><h4 id="why-are-foreign-keys-needed" tabindex="-1">WHY ARE FOREIGN KEYS NEEDED? <a class="header-anchor" href="#why-are-foreign-keys-needed" aria-hidden="true">#</a></h4><p>As said before, foreign keys are just some other table&#39;s primary keys. They are &quot;foreigners&quot; in the table they are in and their home is in some other table. Traditionally in a relational database it&#39;s discouraged to save nested data in one database table (for example JSON like nested data format), because nested, complex data objects are quite hard to query efficiently. This is why in relational databases we need to save data in plain, tabular format thus making it impossible to depict relations between entities without primary keys and foreign keys.</p><h4 id="here-s-another-example-of-two-tables-linked-together" tabindex="-1">HERE&#39;S ANOTHER EXAMPLE OF TWO TABLES LINKED TOGETHER <a class="header-anchor" href="#here-s-another-example-of-two-tables-linked-together" aria-hidden="true">#</a></h4><p><img src="'+m+'" alt="sql"></p><p><small><i>an example of blog posts and their comments linked together</i></small></p><p><img src="'+k+'" alt="sql"></p><p>In the above picture there are two tables. The table on the left side is <i>comments</i> and the other is <i>posts</i>. The arrows depict the relations between primary keys and foreign keys.</p><ul><li>post number 1 has two comments <ul><li>comments 1 and 2</li></ul></li><li>post number 2 has one comment <ul><li>comment number 3</li></ul></li><li>post number 3 has no comments.</li></ul><h4 id="inner-join" tabindex="-1">INNER JOIN <a class="header-anchor" href="#inner-join" aria-hidden="true">#</a></h4><p>INNER JOIN fetches only all the matching rows</p><p><img src="'+y+`" alt="sql"></p><div class="language-sql"><pre><code><span class="token comment">-- let&#39;s fetch all the posts and their comments. Leave out the posts that don&#39;t have any comments</span>

<span class="token keyword">SELECT</span> posts<span class="token punctuation">.</span>id<span class="token punctuation">,</span> posts<span class="token punctuation">.</span>body<span class="token punctuation">,</span> comments<span class="token punctuation">.</span><span class="token keyword">comment</span> <span class="token keyword">FROM</span> posts <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> comments <span class="token keyword">ON</span> posts<span class="token punctuation">.</span>id <span class="token operator">=</span> comments<span class="token punctuation">.</span>post_id<span class="token punctuation">;</span>

</code></pre></div><p><img src="`+f+'" alt="sql"></p><p><small><i>The result set returned by the query above</i></small></p><p>In the <i>posts</i> table there are three rows but only posts 1 and 2 are in the result set because the third post has zero comments. Though the post number 3 is missing from the result set, there are still three rows in the result set, because the post number 1 has two comments</p><h4 id="left-join" tabindex="-1">LEFT JOIN <a class="header-anchor" href="#left-join" aria-hidden="true">#</a></h4><p>As opposed to inner join returning only the matching rows from both tables (returned only the posts having comments) using the left join you can fetch all the posts even if they don&#39;t have any comments.</p><p><img src="'+b+`" alt="sql"></p><div class="language-sql"><pre><code><span class="token comment">-- let&#39;s fetch all the posts and their comments, if they have any</span>

<span class="token keyword">SELECT</span> posts<span class="token punctuation">.</span>id<span class="token punctuation">,</span> posts<span class="token punctuation">.</span>body<span class="token punctuation">,</span> comments<span class="token punctuation">.</span><span class="token keyword">comment</span> <span class="token keyword">FROM</span> posts <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> comments <span class="token keyword">ON</span> posts<span class="token punctuation">.</span>id <span class="token operator">=</span> comments<span class="token punctuation">.</span>post_id<span class="token punctuation">;</span>


</code></pre></div><p><img src="`+g+'" alt="sql"></p><p><small><i>The result set returned by the query above</i></small></p><p>Now that we are using <i>LEFT JOIN</i> instead of <i>INNER JOIN</i> the result set includes the third post, but the <i>comment</i> column is NULL because the post doesn&#39;t have any comments.</p><p>When using <i>LEFT JOIN</i> the query will return all the rows from the left-side table of the query</p><div class="info custom-block"><p class="custom-block-title">What the heck is the table on the left-side, what does it mean?</p><p>It is the table on the left side of the join. In this particular example it is the <i>posts</i> table</p></div><p><img src="'+w+`" alt="sql"></p><h4 id="right-join" tabindex="-1">RIGHT JOIN <a class="header-anchor" href="#right-join" aria-hidden="true">#</a></h4><p>Yes, there is a right join also</p><div class="language-sql"><pre><code>
<span class="token comment">-- this query will return exactly the same result set as the one with LEFT JOIN, but the tables</span>
<span class="token comment">-- are in a different order</span>

<span class="token keyword">SELECT</span> posts<span class="token punctuation">.</span>id<span class="token punctuation">,</span> posts<span class="token punctuation">.</span>body<span class="token punctuation">,</span> comments<span class="token punctuation">.</span><span class="token keyword">comment</span> <span class="token keyword">FROM</span> comments <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> posts <span class="token keyword">ON</span> posts<span class="token punctuation">.</span>id <span class="token operator">=</span> comments<span class="token punctuation">.</span>post_id<span class="token punctuation">;</span>

</code></pre></div><p>The above query returns exactly the same result set as the query with left join query. The only difference is that the tables are in a different order. Now that we use right join, the post with no comments is fetched because <i>posts</i> table is on the right side of the join.</p><h4 id="cross-join" tabindex="-1">CROSS JOIN <a class="header-anchor" href="#cross-join" aria-hidden="true">#</a></h4><div class="info custom-block"><p class="custom-block-title">INFO</p><p>I&#39;ve never needed <i>CROSS JOIN</i> at work!</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>For this example import menus.sql using PhpMyAdmin from Moodle&#39;s Git repository</p></div><p>Using <i>CROSS JOIN</i> use can create every possible combination of both tables in the query</p><p>If you for example had a <i>menus</i> database and inside there two tables <i>foods</i> and <i>drinks</i> you can create menus by <i>CROSS JOIN</i>ing those two</p><p><img src="`+v+'" alt="sql"></p><p><i><small>foods table</small></i></p><p><img src="'+E+`" alt="sql"></p><p><i><small>drinks table</small></i></p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> food<span class="token punctuation">,</span> drink <span class="token keyword">FROM</span> foods <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> drinks<span class="token punctuation">;</span>

</code></pre></div><br><p><img src="`+T+`" alt="sql"></p><p><i><small>result</small></i></p><h4 id="about-joins" tabindex="-1">ABOUT JOINS <a class="header-anchor" href="#about-joins" aria-hidden="true">#</a></h4><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Basically <i>INNER JOIN</i> and <i>LEFT JOIN</i> are all you need</p></div><p>Joins are made between two tables and there&#39;s always an <i>ON</i> clause to identify the two columns in both tables joining them together in a query.</p><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tableA <span class="token punctuation">[</span><span class="token keyword">INNER</span> <span class="token operator">|</span> <span class="token keyword">LEFT</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span> tableB <span class="token keyword">ON</span> tableA<span class="token punctuation">.</span>primary_key_column <span class="token operator">=</span> tableB<span class="token punctuation">.</span>foreign_key_column

</code></pre></div><div class="tip custom-block"><p class="custom-block-title">ON clause</p><p>Always remember to specify the ON clause when using INNER or LEFT JOIN. a JOIN without an ON clause isn&#39;t a syntax error, so you will get a result, but it most likely isn&#39;t what you are looking for.</p></div><h4 id="alias-as" tabindex="-1">ALIAS (AS) <a class="header-anchor" href="#alias-as" aria-hidden="true">#</a></h4><p>When you are using JOINS ie. joining multiple tables together in one query it&#39;s likely that you&#39;ll have same column names in two or more tables. For example primary key columns are many times just named <i>id</i></p><p>Using alias you can rename tables and columns in a query&#39;s context. This is useful if you have many columns of same name or column / table names are long.</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>id <span class="token keyword">AS</span> postId<span class="token punctuation">,</span> p<span class="token punctuation">.</span>body<span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token keyword">comment</span> <span class="token keyword">FROM</span> posts <span class="token keyword">AS</span> p <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> comments <span class="token keyword">AS</span> c <span class="token keyword">ON</span> p<span class="token punctuation">.</span>id <span class="token operator">=</span> c<span class="token punctuation">.</span>post_id<span class="token punctuation">;</span>

</code></pre></div><h4 id="self-join" tabindex="-1">SELF JOIN <a class="header-anchor" href="#self-join" aria-hidden="true">#</a></h4><p><i>SELF JOIN</i> isn&#39;t a third type of join it just means that you create multiple aliases to one table.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Get blog2_example.sql dump from git material repository</p></div><p>As you can see the blog2_example database is like the original blog database but with only 1 table <i>posts</i> Since there&#39;s no difference if the post is actually the first post of a thread or if it is a response to another post, there all are simply posts.</p><div class="info custom-block"><p class="custom-block-title">what is the parent_id column</p><p>Now that all the posts are in one table, there is parent_id column. If parent_id is NULL it means that the post is the first one of a thread, if it&#39;s not NULL the value is the id of the post it&#39;s a response to.</p></div><div class="language-sql"><pre><code><span class="token comment">-- let&#39;s fetch all the posts and their parents</span>

<span class="token keyword">SELECT</span> p1<span class="token punctuation">.</span>id<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>body<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>body <span class="token keyword">AS</span> parent <span class="token keyword">FROM</span> posts <span class="token keyword">AS</span> p1 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> posts <span class="token keyword">AS</span> p2 <span class="token keyword">ON</span> p2<span class="token punctuation">.</span>id <span class="token operator">=</span> p1<span class="token punctuation">.</span>parent_id<span class="token punctuation">;</span>

</code></pre></div><p>There are basically three different aliases. <i>p1</i> and <i>p2</i> are both aliases of the <i>posts</i> table and <i>parent</i> is the body of the parent post</p><p><img src="`+A+`" alt="sql"></p><p><i><small>The result set of the query above</small></i></p><p>See that the first post&#39;s parent is NULL because the it is the first post of a thread and thus has no parent.</p><h4 id="can-tables-be-joined-only-by-using-primary-and-foreign-key-columns" tabindex="-1">CAN TABLES BE JOINED ONLY BY USING PRIMARY AND FOREIGN KEY COLUMNS? <a class="header-anchor" href="#can-tables-be-joined-only-by-using-primary-and-foreign-key-columns" aria-hidden="true">#</a></h4><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>For this example you need to import <i>db_without_primarykeys.sql</i> from Git repository (link in Moodle)</p></div><p>No using primary keys and foreign keys to join tables together isn&#39;t required. You can basically use any column as long as they have matching values. Just like in our example here</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> users<span class="token punctuation">.</span>email <span class="token keyword">FROM</span> vehicles <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> users <span class="token keyword">ON</span> users<span class="token punctuation">.</span>email <span class="token operator">=</span> vehicles<span class="token punctuation">.</span>email<span class="token punctuation">;</span>


</code></pre></div><p>In fact, when the joining columns are of the same name (like here we have <i>email</i>) there&#39;s no need to use <i>ON</i> clause. Instead there&#39;s a shorter version</p><div class="language-sql"><pre><code>
<span class="token comment">-- with USING(column_name) you can shorten the query because the column name is the same in both tables</span>


<span class="token keyword">SELECT</span> make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> users<span class="token punctuation">.</span>email <span class="token keyword">FROM</span> vehicles <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> users <span class="token keyword">USING</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Nonetheless it&#39;s recommended to use <i>JOIN</i> between primary keys and foreign keys because they never change. In this particular example, if the user&#39;s email were to change, we would have to update all the rows in both tables that the email is mentioned. If we instead had primary key key in <i>users</i> table and a corresponding foreign key column <i>users_id</i> in the <i>vehicles</i> table we could update the email as many times as needed without any changes to the <i>vehicles</i> table.</p><h3 id="excercise-1" tabindex="-1">EXCERCISE #1 <a class="header-anchor" href="#excercise-1" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>use tiedonhallinta_harjoitus.sql for this</p></div><ul><li>This excercise has to be returned</li><li>Return only one txt file (not .doc / docx / pdf or any other than .txt)</li><li>Name the file excercise1.txt and keep every query in a separate row as shown in the example below</li><li>If the result set&#39;s columns are not specified, you can select them all</li></ul><p>1.1 SELECT ..... FROM ...;</p><p>1.2 SELECT ....;</p><p>1.3 SELECT ...; and so on</p><ul><li><p>Do <strong>NOT</strong> return the query&#39;s result set, the query is enough (my result set might differ from yours so there&#39;s no point in copying the result set)</p></li><li><p>Every correct query is worth 1 point and a wrong query is worth nothing (0 points)</p><ul><li>wrong query means that it can have a syntax error (it cannot be executed)</li><li>or the result set is incorrect</li></ul></li><li><p>1.1 Create a query that fetches all the employees (all columns)</p></li><li><p>1.2 Create a query that fetches all the departments (all columns)</p></li><li><p>1.3 Create a query that fetches only the tenth employee from the employees table (all columns)</p><ul><li>use primary key column when filtering</li><li>check out the primary key column value of the tenth employee</li></ul></li><li><p>1.4 Create a query that fetches only the last department</p><ul><li>last department being the row with the highest value of the <i>id</i> column</li><li>you can check the value of the hightest id from the database table</li></ul></li><li><p>1.5 Create a query that fetches only the 20th employee&#39;s first_name and salary</p><ul><li>columns: first_name, salary</li><li>you can use id column for filtering</li></ul></li><li><p>1.6 Create a query that fetches the department_id of the 12th employee</p><ul><li>column: only department_id</li><li>use id column for filtering</li></ul></li><li><p>1.7 Create a query that fetches all the employees whose last_name is kuru (all columns)</p></li><li><p>1.8 Create a query that fetches all the employees working at the department_id 3</p><ul><li>use emplyoees table&#39;s department_id to filter</li><li>you can fetch all columns</li></ul></li><li><p>1.9 Create a query modifying the 1.8 query</p><ul><li>use INNER JOIN to join departments table with users table and use departments table&#39;s id column for filtering</li></ul></li></ul><h3 id="aggregate-functions" tabindex="-1">AGGREGATE FUNCTIONS <a class="header-anchor" href="#aggregate-functions" aria-hidden="true">#</a></h3><p>Like the name suggests aggregate functions aggregate many values into one value</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>It&#39;s a good practice to use alias with aggreagate functions to make the result more readable.</p></div><h4 id="avg" tabindex="-1">AVG <a class="header-anchor" href="#avg" aria-hidden="true">#</a></h4><p>AVG calculates the average of the given column</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_salary <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><h4 id="sum" tabindex="-1">SUM <a class="header-anchor" href="#sum" aria-hidden="true">#</a></h4><p>SUM sums up the the values of the given column</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_salary <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><h4 id="min-and-max" tabindex="-1">MIN and MAX <a class="header-anchor" href="#min-and-max" aria-hidden="true">#</a></h4><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> min_salary<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> max_salary <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><p>You can also filter the result set of an aggregate query as you would of a normal <i>SELECT</i> query</p><h4 id="count" tabindex="-1">COUNT <a class="header-anchor" href="#count" aria-hidden="true">#</a></h4><p>with count you can count all the rows</p><div class="language-sql"><pre><code>
<span class="token comment">-- let&#39;s count all the number of employees working in the  department with id 2</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_of_emp <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="aggregate-functions-and-group-by" tabindex="-1">AGGREGATE FUNCTIONS AND GROUP BY <a class="header-anchor" href="#aggregate-functions-and-group-by" aria-hidden="true">#</a></h4><p>As said, by default aggregate functions aggregate many values into one value but you can change its behaviour using <i>GROUP BY</i> clause</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_of_emp <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id<span class="token punctuation">;</span>

</code></pre></div><p>The above query produces number of employees for each department and if results were to be summed it&#39;s the total number of employees working for the company</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_of_emp <span class="token keyword">FROM</span> employees

</code></pre></div><div class="danger custom-block"><p class="custom-block-title">Do NOT ever</p><p>mix aggregate functions with other columns in a select query without using GROUP BY</p></div><p>Let&#39;s see an example of a query like this with MySQL and Postgres</p><h4 id="mysql" tabindex="-1">MYSQL <a class="header-anchor" href="#mysql" aria-hidden="true">#</a></h4><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><p><img src="`+O+`" alt="sql"></p><p>At first glance the result of the query seems to be right, but it&#39;s not. The result implies that there are 99 employees and all of their names are toni. <b>That&#39;s just not right. MySQL just returns the first employee&#39;s name</b></p><h4 id="postgres" tabindex="-1">Postgres <a class="header-anchor" href="#postgres" aria-hidden="true">#</a></h4><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><p><img src="`+N+`" alt="sql"></p><p>This is the right behaviour in this situation because you simply cannot mix columns normally with aggregate functions without using <i>GROUP BY</i> or aggregating both columns Because if you think of the query as two separate ones</p><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> first_name <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>
</code></pre></div><p>This returns 99 rows</p><p>and</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><p>this returns one row</p><p>So they simply cannot be presented in one result set without <i>GROUP BY</i> or aggregating both columns</p><div class="language-sql"><pre><code><span class="token comment">-- fix the query using GROUP BY</span>
<span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> c <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> first_name<span class="token punctuation">;</span>
<span class="token comment">-- or by aggregating both columns so that they both return one row</span>
<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>first_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> c <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><p>You can also have multiple columns in a <i>GROUP BY</i></p><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span> department_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> last_name<span class="token punctuation">,</span> department_id<span class="token punctuation">;</span>

</code></pre></div><p>This query counts all the employees by their last_name and department_id</p><h4 id="aggregate-functions-and-having" tabindex="-1">AGGREGATE FUNCTIONS AND HAVING <a class="header-anchor" href="#aggregate-functions-and-having" aria-hidden="true">#</a></h4><p>Let&#39;s first fetch all the department_ids and their average salary</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id<span class="token punctuation">;</span>

</code></pre></div><p>Now let&#39;s modify the query to fetch only the departments whose average salary is more than 4200</p><div class="danger custom-block"><p class="custom-block-title">this won&#39;t work</p><p>SELECT department_id, AVG(salary) FROM employees WHERE AVG(salary) &gt; 4200 GROUP BY department_id;</p></div><p>This won&#39;t work, because it&#39;s not possible to use aggregate functions in a <i>WHERE</i> clause. For this we&#39;ve got <i>HAVING</i></p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id <span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span><span class="token punctuation">;</span>

</code></pre></div><p>When you need to filter the groups produced by <i>GROUP BY</i> use <i>HAVING</i> instead of <i>WHERE</i></p><h4 id="subquery" tabindex="-1">SUBQUERY <a class="header-anchor" href="#subquery" aria-hidden="true">#</a></h4><div class="info custom-block"><p class="custom-block-title">INFO</p><p>But if using aggregate function in a <i>WHERE</i> clause isn&#39;t possible, how can I fetch for example all the employees whose salary is more than the company&#39;s average salary</p></div><p><b>You can use subquery to produce the average salary and use that result in a <i>WHERE</i> clause</b></p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> salary <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> salary <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><h3 id="scalar-functions" tabindex="-1">SCALAR FUNCTIONS <a class="header-anchor" href="#scalar-functions" aria-hidden="true">#</a></h3><p>Scalar functions don&#39;t aggregate, instead the function is executed on each row individually</p><h4 id="concat" tabindex="-1">CONCAT <a class="header-anchor" href="#concat" aria-hidden="true">#</a></h4><p>Concatenates two or more strings into one</p><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> <span class="token string">&#39; &#39;</span><span class="token punctuation">,</span> last_name<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><h4 id="upper" tabindex="-1">UPPER <a class="header-anchor" href="#upper" aria-hidden="true">#</a></h4><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> UPPER<span class="token punctuation">(</span>first_name<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><h4 id="lower" tabindex="-1">LOWER <a class="header-anchor" href="#lower" aria-hidden="true">#</a></h4><div class="language-sql"><pre><code>
<span class="token keyword">SELECT</span> LOWER<span class="token punctuation">(</span>first_name<span class="token punctuation">)</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

</code></pre></div><h4 id="now" tabindex="-1">NOW <a class="header-anchor" href="#now" aria-hidden="true">#</a></h4><p>NOW returns the current timestamp. It&#39;s useful for example calculating differences between two timestamps</p><h4 id="timestampdiff" tabindex="-1">TIMESTAMPDIFF <a class="header-anchor" href="#timestampdiff" aria-hidden="true">#</a></h4><p>Calculates the difference between two timestamps in the given unit</p><div class="language-sql"><pre><code><span class="token comment">-- this doesn&#39;t work in postgres, because it doesnt have timestampdiff</span>
<span class="token keyword">SELECT</span> TIMESTAMPDIFF<span class="token punctuation">(</span><span class="token keyword">HOUR</span><span class="token punctuation">,</span><span class="token string">&#39;2022-02-01&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;2022-02-21&#39;</span><span class="token punctuation">)</span>
<span class="token comment">-- in postgress you would have to do something like this.</span>
<span class="token keyword">select</span> extract<span class="token punctuation">(</span>epoch <span class="token keyword">from</span> <span class="token string">&#39;2022-02-21&#39;</span>::<span class="token keyword">timestamp</span> <span class="token operator">-</span> <span class="token string">&#39;2022-02-01&#39;</span>::<span class="token keyword">timestamp</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3600</span>
</code></pre></div><p>Combining <i>TIMESTAMPDIFF</i> with <i>NOW</i> is useful when calculating for example user&#39;s age. It might seem handy at first to save the age as INTEGER into the database but age is something that constantly changes so it&#39;s more useful to sve the date of birth and calculate the user&#39;s age based on that.</p><h3 id="order-by" tabindex="-1">ORDER BY <a class="header-anchor" href="#order-by" aria-hidden="true">#</a></h3><p>With <i>ORDER BY</i> you can change the order of the result set. This might be useful especially when using aggregate functions because they lose the unique identifiers of each row</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>You can use column alias in order by</p></div><div class="language-sql"><pre><code><span class="token comment">-- let&#39;s find all the departments whose average salary is more than 4200 and order the result set in the ascending order</span>
<span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_salary <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id <span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> avg_salary
<span class="token comment">-- it&#39;s the same as this</span>
<span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_salary <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id <span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> avg_salary <span class="token keyword">ASC</span>
<span class="token comment">-- let&#39;s now flip the order</span>
<span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_salary <span class="token keyword">FROM</span> employees <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id <span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> avg_salary <span class="token keyword">DESC</span>
</code></pre></div><h3 id="insert" tabindex="-1">INSERT <a class="header-anchor" href="#insert" aria-hidden="true">#</a></h3><p><img src="`+q+`" alt="sql"></p><p>There&#39;s always the same pattern in <i>INSERT</i></p><div class="language-sql"><pre><code>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tablename<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>columnN<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>valueN<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The example query in the picture is an insert into todo_items. In the todo_items table there are three columns but there are only two columns specified in the insert query. That&#39;s because the third column is id and that&#39;s an AI (auto increment) column, that the db system takes care of internally, so we don&#39;t have to insert it manually</p><p>It&#39;s the same with status column. We&#39;ve specified a default value of 0 for it, so it could have been left empty in the insert query</p></div><h3 id="update" tabindex="-1">UPDATE <a class="header-anchor" href="#update" aria-hidden="true">#</a></h3><p>Using update you can update existing rows</p><p><img src="`+S+`" alt="sql"></p><div class="language-sql"><pre><code>
<span class="token keyword">UPDATE</span> tablename <span class="token keyword">SET</span> column1 <span class="token operator">=</span> <span class="token string">&#39;newvalue&#39;</span><span class="token punctuation">,</span> column2 <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">WHERE</span> column2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

</code></pre></div><p>There&#39;s no updateOne or updateMany in SQL. The damage control is done by using WHERE properly. So the WHERE clause determines how many rows get updated</p><p>In the example picture there&#39;s <i>WHERE id = 1;</i> so only one row gets updated because id column values are unique</p><div class="language-sql"><pre><code>
<span class="token comment">-- let&#39;s update all the pending tasks and set their status as done</span>
<span class="token keyword">UPDATE</span> todo_items <span class="token keyword">SET</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

</code></pre></div><div class="warning custom-block"><p class="custom-block-title">UPDATE without WHERE</p><p>Update without WHERE updates all the rows in the table so</p><p>if you are updating without WHERE clause, you are most likely almost always doing something wrong!</p><p>If you are not sure about how many rows your update will affect, use SELECT first and then UPDATE using the same WHERE clause</p></div><h3 id="delete" tabindex="-1">DELETE <a class="header-anchor" href="#delete" aria-hidden="true">#</a></h3><p>Using <i>DELETE</i> you can remove rows from a table</p><p><img src="`+R+'" alt="sql"></p><p>With <i>DELETE</i> you must not specify columns, because in a relational database every table has a strict schema that is specified beforehand, so it&#39;s not possible to remove individual columns. <b>You only remove rows</b></p><p>With <i>DELETE</i> it&#39;s the same as with <i>UPDATE</i>. There&#39;s no deleteOne or deleteMany you can control the nubmer of rows removed by filtering using <i>WHERE</i></p><h3 id="excercise-2" tabindex="-1">EXCERCISE #2 <a class="header-anchor" href="#excercise-2" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Download and import tiedonhallinta_harjoitus2.sql</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>This excercise has to be returned</p><ul><li>Return only one txt file (not .doc / docx / pdf or any other than .txt)</li><li>Name the file excercise2.txt and keep every query in a separate row as shown in the example below</li></ul><p>2.1 SELECT ...;</p><p>2.2 SELECT ...;</p></div><div class="tip custom-block"><p class="custom-block-title">*</p><p>In 2.4 and 2.5 you can use either the finnish or the english name of the department. You don&#39;t have to redo this excercise if you&#39;ve already done it with the finnish department names But if you haven&#39;t done this already, you can use the sql file with english department names</p></div><ul><li><p>2.1 Create a query that fetches the average salary of all the employees</p></li><li><p>2.2 Create a query that fetches the lowest salary of all the employees</p></li><li><p>2.3 Create a query that fetches the highest salary of all the employees</p></li><li><p>2.4 Create a query that fetches the highest salary in the <i>sovelluskehitys</i> or <i>software development</i>* department</p><ul><li>you must use INNER JOIN</li><li>you must use the name of the department in departments table</li></ul></li><li><p>2.5 Create a query that fetches the lowest salary in the <i>palkat</i> or <i>salaries</i>* department</p><ul><li>you must use INNER JOIN</li><li>you must use the name of the department in departments table</li></ul></li><li><p>2.6 Create a query that fetches average salaries by department</p><ul><li>two column in the result set (department name, department&#39;s average salary)</li></ul></li><li><p>2.7 Create a query that adds a new department named RnD-department</p></li><li><p>2.8 Create a query that fetches all the employees&#39; first_name and last_name and the name of the department they work in</p><ul><li>you must use INNER JOIN</li><li>the result set contains three columns (first_name, last_name <a href="http://departments.name" target="_blank" rel="noopener noreferrer">departments.name</a>)</li></ul></li><li><p>2.9 Create a query that fetches only the department(s) with zero employees</p><ul><li>the only department is the RnD-department added in 2.7</li><li>this can be done using LEFT JOIN</li><li>filter using IS keyword</li><li>the result set should contain only the name of the department (one column)</li></ul></li><li><p>2.10 Create a query that fetches all the departments and their average salaries whose average salary is more than 3500</p><ul><li>result set: name of the department, average salary</li></ul></li><li><p>2.11 Create a query that fetches the number of employees by department</p><ul><li>result set (name of the department, number of employees)</li><li>you must use JOIN</li><li>you must use column alias <i>num_of_employees</i> as the number of employees</li></ul></li><li><p>2.12 Create a query that fetches all the employees whose salary is less than the average salary</p><ul><li>result set: full_name, salary (two columns)</li><li>full_name is a concatenation of first_name and last_name separated by white space</li><li>you must use column alias <i>full_name</i></li></ul></li><li><p>2.13 Create a query that fetches all the employees whose salary is less than the average salary of the department they work in</p><ul><li>use subquery</li><li>result set: all the columns in the employees table</li><li>tip: this can be done by comparing employees table to itself using two aliases</li></ul></li><li><p>2.14 Create a query that fetches every employees salary and the average salary of the whole company</p><ul><li>result set: salary, avg_salary (two columns)</li><li>you must use column alias <i>avg_salary</i></li><li>tip: easiest way is to use subquery</li></ul></li><li><p>2.15 Create a query that fetches every employees salary and the lowest salary of the department they work in</p><ul><li>result set: salary, lowest_salary_of_dep (two columns)</li><li>you must use column alias <i>lowest_salary_of dep</i></li></ul></li></ul>',294),C=[L];function x(M,_,F,W,U,Y){return s(),e("div",null,C)}var G=a(I,[["render",x]]);export{B as __pageData,G as default};
