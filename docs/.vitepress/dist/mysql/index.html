<!DOCTYPE html>
<html lang="fi-FI">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Relaatiotietokannat | SQL and NoSQL</title>
    <meta name="description" content="Kuvaus">
    <link rel="stylesheet" href="/assets/style.2759ba08.css">
    <link rel="modulepreload" href="/assets/plugin-vue_export-helper.86aaabad.js">
    <link rel="modulepreload" href="/assets/Home.f7831201.js">
    <link rel="modulepreload" href="/assets/mysql_index.md.56cbdcfa.lean.js">
    <link rel="modulepreload" href="/assets/app.6b6d40d7.js">
    
    <meta name="twitter:title" content="Relaatiotietokannat | SQL and NoSQL">
  <meta property="og:title" content="Relaatiotietokannat | SQL and NoSQL">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="SQL and NoSQL, back to home" data-v-675d8756 data-v-4a583abe><!----> SQL and NoSQL</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/info/" data-v-b8818f8c>Info <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/softwares/" data-v-b8818f8c>Softwares <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/db/" data-v-b8818f8c>Database? <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/sql/" data-v-b8818f8c>Relational Database <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/design/" data-v-b8818f8c>Database design <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/dw/" data-v-b8818f8c>Data warehousing <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/nosql/" data-v-b8818f8c>NoSQL <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/info/" data-v-b8818f8c>Info <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/softwares/" data-v-b8818f8c>Softwares <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/db/" data-v-b8818f8c>Database? <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/sql/" data-v-b8818f8c>Relational Database <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/design/" data-v-b8818f8c>Database design <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/dw/" data-v-b8818f8c>Data warehousing <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/nosql/" data-v-b8818f8c>NoSQL <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#relaatiotietokannat">Relaatiotietokannat</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#mysql-mariadb">MySQL / MariaDB</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#relaatiotietokantojen-rakenne">Relaatiotietokantojen rakenne</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#mysql-n-kaytto-koodarin-nakokulmasta">MySQL:n käyttö koodarin näkökulmasta</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tuntiharjoitus-1">Tuntiharjoitus 1.</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#sql-kieli">SQL-kieli</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#sql-n-komentoja">SQL:n komentoja</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#select">SELECT</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#vertailuoperaattorit">VERTAILUOPERAATTORIT</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#sumea-haku">SUMEA HAKU</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#joinit">JOINIT</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#perusavain-primary-key-ja-viiteavain-foreign-key">Perusavain (Primary Key) ja Viiteavain (Foreign Key)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#inner-join">INNER JOIN</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#left-join">LEFT JOIN</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#right-join">RIGHT JOIN</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#full-join">FULL JOIN</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#joineista">JOINeista</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#alias-as">ALIAS (AS)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#self-join">SELF JOIN</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tehtavat-1-palautettava">Tehtävät 1 (palautettava)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#koostefunktiot-aggregate-functions">KOOSTEFUNKTIOT (AGGREGATE FUNCTIONS)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#koostefunktiot-ja-group-by">KOOSTEFUNKTIOT JA GROUP BY</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#koostefunktiot-ja-having">KOOSTEFUNKTIOT JA HAVING</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#skalaarifunktiot-scalar-functions">SKALAARIFUNKTIOT (SCALAR FUNCTIONS)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#order-by">ORDER BY</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#insert">INSERT</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#delete">DELETE</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#update">UPDATE</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#alikysely-subquery">ALIKYSELY (SUBQUERY)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tehtavat-2-palautettava">TEHTÄVÄT 2 (palautettava)</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tehtavat-3-palautettava">TEHTÄVÄT 3 (palautettava)</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="relaatiotietokannat" tabindex="-1">Relaatiotietokannat <a class="header-anchor" href="#relaatiotietokannat" aria-hidden="true">#</a></h2><ul><li><p>Relaatiotietokannat perustuvat tietokantatauluihin, joiden rakenne on määritelty</p><ul><li>määrittely tarkoittaa tietokantataulujen sarakkeiden nimeämistä, sen tietotyypin määrittämistä jne.</li><li>Relaatiotietokantataulun rakenne on siis strukturoitu, eli tarkkaan etukäteen määritetty</li><li>vrt. esim. MongoDB collection (vastaa relaatietokannan taulua), joka voi olla strukturoitu, semistrukturoitu tai kokonaan ilman ennakkoon määriteltyä rakennetta</li></ul></li><li><p>Yksittäinen taulu sisältää tietoja vain tietyntyyppisistä kohteista</p><ul><li>esim. asiakas tai lemmikki</li><li>Samaan tauluun ei siis tallennetta ensin asiakastietoja ja yhtäkkiä seuraavalle riville lemmikin tietoja</li><li>kaikkien lemmikkien tiedot tallennetaan omaan tauluun ja asiakkaat omaan tauluun</li><li>Taulu koostuu riveistä ja sarakkeista niin kuin taulukkolaskentadokumenttikin (Excel)</li></ul></li></ul><h3 id="mysql-mariadb" tabindex="-1">MySQL / MariaDB <a class="header-anchor" href="#mysql-mariadb" aria-hidden="true">#</a></h3><ul><li><p>MySQL on relaatiotietokantaohjelmisto, joka on saatavilla sekä vapaalla GPL-lisenssillä että kaupallisella linsenssillä</p></li><li><p>Alunperin kehittämineet suomalainen Michael &quot;Monty&quot; Widenius ja ruotsalainen David Axmark</p></li><li><p>Ensimmäinen versio julkaistu 1996 ja kehitetään edelleen</p></li><li><p>Nykyisin Oraclen omistuksessa</p></li><li><p>MariaDB ilmestyi, kun MySQL siirtyi Oraclen omistukseen</p></li><li><p>MariaDB on MySQL:n avoimen lähdekoodin versioon pohjautuva tietokantapalvelin</p></li><li><p>Sama kehittäjä kuin alkuperäisellä MySQL:llä ja on tarkoituksena olla ns. &#39;drop-in replacement&#39; MySQL:n avoimen lähdekoodin versiolle</p><ul><li>Käyttäjä ei välttämättä huomaa eroa käyttäessään MySQL:ää / MariaDB:tä</li></ul></li></ul><h3 id="relaatiotietokantojen-rakenne" tabindex="-1">Relaatiotietokantojen rakenne <a class="header-anchor" href="#relaatiotietokantojen-rakenne" aria-hidden="true">#</a></h3><ul><li>Yksittäinen tietokanta koostuu yhdestä tai useammasta taulusta</li></ul><ul><li>Periaatteessa voi olla myös tietokanta, jossa ei ole yhtään taulua, mutta sitten tietokantakin on sama poistaa</li></ul><ul><li>Taulut koostuvat riveistä ja sarakkeista</li><li>Taulun sarakkeet ovat ennalta määrättyjä tietokannan suunnitteluvaiheessa <ul><li>Jokaisella sarakkeella on tarkkaan suunnitteluvaiheessa määritetty tietotyyppi, esim. kokonaisluku, merkkijono, päivämäärä ja aika</li></ul></li></ul><h4 id="taulut" tabindex="-1">Taulut <a class="header-anchor" href="#taulut" aria-hidden="true">#</a></h4><p><img src="/assets/1.0717bc5d.png" alt="mysql"></p><ul><li>Tietokannan taulun voi mieltää lähtökohtaisesti Excelin taulukkolaskenta sheetiksi. <ul><li>sekin koostuu riveistä ja sarakkeista</li><li>Excelissä sarakkeet on nimetty ennakkoon (A, B, C ....jne), mutta relaatiotietokannan taulun sarakkeet määritetään suunnitteluvaiheessa.</li><li>Excelissä sarakkeeseen voi antaa mitä tahansa tietoa (tekstiä, numeroita yms.), mutta relaatiotietokannassa jokaisella taulun sarakkeella on tarkkaan ennaakkoon määritetty tietotyyppi <ul><li>jos siis määrität username-sarakkeen tietotyypiksi merkkijono, siihen ei kirjoittaa kokonaislukua</li></ul></li></ul></li><li>Rivit ovat yksittäisiä tietuita, joita taulun sarakkeet määrittävät <ul><li>Esim. yo. kuvan esimerkissä sarakkeet ovat: <ul><li>id (kokonaisluku)</li><li>username (merkkijono)</li><li>role (merkkijono)</li></ul></li><li>ja yksittäisen käyttäjän tiedot ovat aina samalla rivillä. Esimerkissä on siis 3 eri käyttäjää</li></ul></li></ul><h4 id="vertailukohtana-mongodb" tabindex="-1">Vertailukohtana MongoDB <a class="header-anchor" href="#vertailukohtana-mongodb" aria-hidden="true">#</a></h4><ul><li>Relaatiotietokannassa taulussa on tarkkaan määrätty rakenne (sarakkeiden nimet ja niiden tietotyypit) <ul><li>taulun skeemaan voi kuulua myös muita rajoittavia tekijöitä (esim. unique-indeksi), mutta näistä vasta myöhemmin lisää</li></ul></li><li>MongoDB:ssä ei ole tällaista tarkkaan määritettyä skeemaa, vaan tietotyypit voivat vaihdella dokumenttien välillä</li></ul><p><img src="/assets/2.e3abee7e.png" alt="mongodb"></p><ul><li>yo. kuvassa on vastaanlaista käyttäjädataa MongoDB-collectionissa (collection vastaa relaatiotietokannan taulua) <ul><li>huomaa kuvassa keltaisella korostettu username-kenttä: ylemmällä käyttäjällä username on merkkijono, alemmalla se on numero</li><li>relaatiotietokannoissa tämä ei ole mahdollista, koska jokaisella sarakkeella on tarkkaan määritetty tietotyyppi, ei ole mahdollista sekoittaa eri tietotyyppejä samaan sarakkeeseen</li><li>MongoDB:ssä tiedon eheyden ylläpitämisestä vastataan koodin puolella, relaatiotietokannassa nämä ovat sisäänrakennettuja ominaisuuksia, eikä niitä tarvitse erikseen koodata</li></ul></li></ul><h3 id="mysql-n-kaytto-koodarin-nakokulmasta" tabindex="-1">MySQL:n käyttö koodarin näkökulmasta <a class="header-anchor" href="#mysql-n-kaytto-koodarin-nakokulmasta" aria-hidden="true">#</a></h3><ul><li><p>Tiedonhallinta on paljon muutakin kuin pelkästään tietojen hakemista, tallentamista, muokkaamista ja poistoa tietokannasta, mutta tällä opintojaksolla keskitymme enemmän niihin tietokantojen ominaisuuksiin, mitä koodarit tarvitsevat ja jätämme vähemmälle / kokonaan pois tietokantojen hallinnointiin liittyvät asiat (database administrator on ihan oma työnsä, jota pitää käsitellä toisella opintojaksolla)</p></li><li><p>Aloitamme tekemällä kyselyjä valmiiseen tietokantaan ja vasta myöhemmin keskitymme tietokannan suunnitteluun</p><ul><li>Suunnitteluun käytämme MySQL Workbench-sovellusta</li></ul></li></ul><h3 id="tuntiharjoitus-1" tabindex="-1">Tuntiharjoitus 1. <a class="header-anchor" href="#tuntiharjoitus-1" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">Ennakkovaatimukset</p><p>Tarvitset tätä varten PHP MyAdmin-sovelluksen. Katso <a href="/softwares/" target="_blank">täältä</a> asennusohjeet, jos et ole sitä jo asentanut</p></div><ul><li>Avaa PHP MyAdmin</li><li>Kirjaudu opintojakson työtilaan Moodlessa <ul><li><p>hae materiaaleista git-repositorion linkistä tuntiharjoiuts1.sql ja katso videolta, miten saat sql-tiedostosta tietokannan itsellesi</p><ul><li>Tässä vaiheessa, koska keskitymme kyseyjen tekemiseen, käytämme valmista tietokantaa, jossa on vain yksi taulu</li></ul></li></ul></li></ul><div class="info custom-block"><p class="custom-block-title">lopputulos</p><p>Lopputuloksena sinulla pitäisi olla tietokanta tuntiharjoitus1, jossa yksi taulu: users ja siellä 2 käyttäjää</p></div><h3 id="sql-kieli" tabindex="-1">SQL-kieli <a class="header-anchor" href="#sql-kieli" aria-hidden="true">#</a></h3><ul><li><p>Idea relaatiotietokannoista syntyi jo 70-luvulla, jolloin IBM:n insinööri kirjoitti tutkielman siitä, miten relaatiotietokannat voisivat toimia. Silloisissa IBM:n käyttämissä tietokantamalleissa oli omat ongelmansa tallennettavan datan suhteiden mallintamisessa ja tutkielma pureutui tähän ongelmaan. Kesti kuitenkin vielä vuosia ennen kuin tämän tutkielman pohjalta kehitettiin ensimmäinen relaatiotietokanta siinä samalla myös kieli, jolla tuota relaatiotietokantapalvelinohjelmistoa voidaan käyttää</p></li><li><p>SQL tulee sanoista Structured Query Language</p><ul><li>rakenteellinen kyselykieli</li><li>SQL-kieli on ISO-standardoitu jo vuonna 1986</li></ul></li><li><p>Koska SQL-kieli on standardoitu jo vuonna 1986, se on levinnyt käyttöön kaikkiin relaatiotietokanntaohjelmistoihin. Eri relaatiotietokantavalmistajilla (esim. Oracle, Microsoft, yms.) on omat mausteensa, jolla tavoittelevat kilpailuetua, mutta jokaisen valmistajan tuotteet noudattavat 80-luvulla määritettyä standardia. Tätä voisi verrata siihen, että luokallinen ihmisiä puhuu suomea (samaa kieltä = SQL), mutta eri osista Suomea kotoisin olevilla ihmisillä on eri murre. Pienistä, eri murteiden tuomista eroista huolimatta kaikki puhuvat kuitenkin samaa kieltä ja ymmärtävät siksi toisiaan.</p></li></ul><h3 id="sql-n-komentoja" tabindex="-1">SQL:n komentoja <a class="header-anchor" href="#sql-n-komentoja" aria-hidden="true">#</a></h3><pre><code>* Keskitymme lihavoituihin, koska niitä koodari tarvitsee eniten.
* Tutustumme myös commitiin ja rollbackiin
</code></pre><h4 id="dcl-data-control-language" tabindex="-1">DCL (Data Control Language) <a class="header-anchor" href="#dcl-data-control-language" aria-hidden="true">#</a></h4><ul><li>grant (voidaan esim. antaa käyttäjille oikeuksia tietokantoihin)</li><li>revoke (voidan esim. peruuttaa grantilla annettuja oikeuksia)</li></ul><h4 id="ddl-data-definition-language" tabindex="-1">DDL (Data Definition Language) <a class="header-anchor" href="#ddl-data-definition-language" aria-hidden="true">#</a></h4><ul><li>create (luodaan tietokanta, taulu, view ym.)</li><li>drop (voidaan poistaa tietokanta, taulu, view ym.)</li><li>rename (voidaan esim. nimetä uudelleen taulu tai taulun sarake)</li><li>truncate (niin kuin drop, mutta tyhjentää, ei poista taulua)</li></ul><h4 id="tcl-trnasaction-control-language" tabindex="-1">TCL (Trnasaction Control Language) <a class="header-anchor" href="#tcl-trnasaction-control-language" aria-hidden="true">#</a></h4><ul><li>commit</li><li>rollback</li></ul><h4 id="dql-data-query-language" tabindex="-1">DQL (Data Query Language) <a class="header-anchor" href="#dql-data-query-language" aria-hidden="true">#</a></h4><ul><li><b>select (haetaan tietokannasta tietoja)</b></li></ul><h4 id="dml-data-modification-language" tabindex="-1">DML (Data Modification Language) <a class="header-anchor" href="#dml-data-modification-language" aria-hidden="true">#</a></h4><ul><li><b>insert (voidaan esim. lisätä rivejä tauluun)</b></li><li><b>update (voidaan muokata oo. riviä / rivejä taulussa)</b></li><li><b>delete (voidaan poistaa rivi / rivejä taulusta)</b></li></ul><h3 id="select" tabindex="-1">SELECT <a class="header-anchor" href="#select" aria-hidden="true">#</a></h3><ul><li>SELECT-lauseella haetaan tietoja kannasta. Select ei muokkaa, lisää, eikä poista tietoja kannasta</li></ul><p><img src="/assets/3.12f54fc9.png" alt="mongodb"></p><ul><li><p>SELECT-lausekkeessa on aina sama kaava:</p><ul><li>alkaa avainsanalla SELECT</li><li>sen jälkeen listataan sarakkeet, jotka halutaan hakea</li><li>sen jälkeen tulee FROM [taulun nimi]</li></ul></li><li><p>jos haluat hakea kaikki sarakkeet taulusta, voit käyttää myös tähteä * merkkaamaan kaikkia sarakkeita</p></li></ul><div class="language-bash"><pre><code><span class="token comment"># tämä sql-lauseke hakee users taulusta kaikki käyttäjät.</span>
<span class="token comment"># lopputulos on täysin sama kuin yo. kuvan kyselyssä</span>

SELECT * FROM <span class="token function">users</span><span class="token punctuation">;</span>

</code></pre></div><div class="tip custom-block"><p class="custom-block-title">VRT MongoDB</p><p>db.users.find()</p></div><ul><li>Esimerkiksi MongoDB:ssä on yhden rivin hakua varten findOne-funktio, mutta SQL-kielessä ei ole SELECT ONE-avainsanaa vaan ainoastaan SELECT haettiin sitten yhtä tai useampaa riviä.</li><li>SQL-kielessä haun rajauksen voi tehdä esimerkiksi käyttäen LIMIT-avainsamaa</li></ul><div class="language-bash"><pre><code>    SELECT * FROM <span class="token function">users</span> LIMIT <span class="token number">0</span>, <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">VRT MongoDB</p><p>db.users.findOne()</p></div><h4 id="limit" tabindex="-1">LIMIT <a class="header-anchor" href="#limit" aria-hidden="true">#</a></h4><p>LIMIT-avainsana hyväksyy kaksi kokonaislukua</p><ul><li>ensimmäinen on OFFSET eli se, mistä lähdetään liikkeelle</li><li>toinen on ROWCOUNT eli kuinka monta riviä haetaan tulokseen</li></ul><p>Esim. <i>SELECT * FROM users LIMIT 0,1</i> hakee ensimmäisen, koska OFFSET on nolla, niin lähdetään ensimmäisestä liikkeelle ja ROWCOUNT on 1, niin haetaan vain yksi</p><div class="language-bash"><pre><code><span class="token comment"># ao. rivi hakee toisen käyttäjän, koska OFFSET on 1, hypätään yksi käyttäjä yli</span>

SELECT * FROM <span class="token function">users</span> LIMIT <span class="token number">1,1</span>

</code></pre></div><h4 id="where" tabindex="-1">WHERE <a class="header-anchor" href="#where" aria-hidden="true">#</a></h4><ul><li>WHERE-avainsanalla kyselyyn voi lisätä rajaavia ehtoja <ul><li>rajaavina ehtoina voi käyttää taulun sarakkeita</li></ul></li></ul><div class="language-bash"><pre><code>    <span class="token comment"># Haetaan käyttäjä, jonka id-sarakkeen arvo on 1</span>
    <span class="token comment"># Huom, koska id on perusavain (Primary Key), id:n arvo on jokaselle käyttäjälle yksilöllinen. Tämän kyselyn tuloksena tulee siis vain yksi käyttäjä</span>
    SELECT * FROM <span class="token function">users</span> WHERE <span class="token function">id</span> <span class="token operator">=</span> <span class="token number">1</span>

    <span class="token comment"># haetaan käyttäjä, jonka etunimi on jorma</span>
    <span class="token comment"># Tämän kyselyn tuloksena voi tulla useita käyttäjiä, koska useammalla ihmisellä voi olla sama etunimi</span>
    SELECT * FROM <span class="token function">users</span> WHERE first_name <span class="token operator">=</span> <span class="token string">&#39;jorma&#39;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">VRT MongoDB</p><p>Koska yo. esimerkissä <i>SELECT * FROM users WHERE id = 1</i> kysely palauttaa aina vaan yhden käyttäjän, voimme käyttää siinä findOne-funktiota ja <i>SELECT * FROM users WHERE first_name = &#39;jorma&#39;</i> voi palauttaa useamman tuloksen, joten käytämme siinä find-metodia</p></div><div class="language-bash"><pre><code><span class="token comment"># hetaan käyttäjä käyttäen yksilöllistä _id-saraketta MongoDB-tietokannasta</span>

db.users.findOne<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&#39;_id&#39;</span><span class="token builtin class-name">:</span> ObjectId<span class="token punctuation">(</span><span class="token string">&#39;63b40c56a16aafe7015b2fc4&#39;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment"># haetaan käyttäjä(t) jonka / joiden etunimi on jorma</span>

db.users.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&#39;first_name&#39;</span><span class="token builtin class-name">:</span> <span class="token string">&#39;jorma&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h4 id="or-ja-and" tabindex="-1">OR ja AND <a class="header-anchor" href="#or-ja-and" aria-hidden="true">#</a></h4><ul><li>Ehtoja voi myös yhdistellä käyttäen OR:ia ja AND:ia kuten Pythonissakin</li></ul><div class="language-bash"><pre><code><span class="token comment"># Haetaan kaikkien käyttäjien etunimi, joiden etunimi on Matti tai Juhani</span>
SELECT first_name, last_name FROM <span class="token function">users</span> WHERE first_name <span class="token operator">=</span> <span class="token string">&#39;Juhani&#39;</span> OR first_name <span class="token operator">=</span> <span class="token string">&#39;Matti&#39;</span> 

</code></pre></div><div class="language-bash"><pre><code><span class="token comment"># Haetaan kaikkien käyttäjien roolit, joiden etunimi on Juhani ja sukunimi Kuru</span>
SELECT role FROM <span class="token function">users</span> WHERE first_name <span class="token operator">=</span> <span class="token string">&#39;Juhani&#39;</span> AND last_name <span class="token operator">=</span> <span class="token string">&#39;Kuru&#39;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">SULUILLA VOIT MUUTTAA EHTOJEN VAIKUTUSTA KYSELYN TULOKSEEN</p><p>Hae git-reposta Moodlen kautta tiedonhallinta_harjoitus.sql-tiedosto ja tuo se PhpMyAdminilla koneelle Suorita seuraavat kyselyt PhpMyAdminissa</p></div><div class="language-bash"><pre><code><span class="token number">1</span>. SELECT * FROM employees WHERE first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span> OR last_name <span class="token operator">=</span> <span class="token string">&#39;kuru&#39;</span> AND department_id <span class="token operator">=</span> <span class="token number">2</span> 
</code></pre></div><p>Saamasi tulos voi hieman vaihdella ao. kuvan tulokseta, koska tiedot taulussa voivat vaihdella.</p><p><img src="/assets/6.48cc885e.png" alt="mysql"></p><p>Mutta tuloksessa oleellista on, että saat vastauksena myös muita kuin department_id 2:n työntekijöitä.</p><p>Tämä johtuu siitä, että AND-ehto vaikuttaa vain niihin, joiden last_name-sarakkeessa on kuru (eli tuloksessa kaikki, joiden sukunimi on kuru department_id on 2, mutta tuloksena voi tulla muitakin department_id:n arvoja)</p><div class="language-bash"><pre><code><span class="token number">2</span>. SELECT * FROM employees WHERE first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span> AND department_id <span class="token operator">=</span> <span class="token number">2</span> OR last_name <span class="token operator">=</span> <span class="token string">&#39;kuru&#39;</span> AND department_id <span class="token operator">=</span> <span class="token number">2</span> 
</code></pre></div><p>Kun suoritat yo. kyselyn numero 2, se hakee vain department_id 2:n työntekijöitä, joiden etunimi on juhani tai sukunimi on kuru, mutta molemmissa tapauksissa kaikki työskentelevät osastolla #2</p><div class="language-bash"><pre><code><span class="token number">3</span>. SELECT * FROM employees WHERE <span class="token punctuation">(</span>first_name <span class="token operator">=</span> <span class="token string">&#39;juhani&#39;</span> OR last_name <span class="token operator">=</span> <span class="token string">&#39;kuru&#39;</span><span class="token punctuation">)</span> AND department_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>Kyselyllä numero 3 on sama tulos, kuin kyselyllä numero 2, mutta se on lyhempi, koska sulut muuttavat ehtojen tulkintaa</p><h3 id="vertailuoperaattorit" tabindex="-1">VERTAILUOPERAATTORIT <a class="header-anchor" href="#vertailuoperaattorit" aria-hidden="true">#</a></h3><ul><li>= (yhtä suuri kuin) <ul><li>huomaa, että ohjelmointikielissä vertailussa käytetään kahta yhtäsuuruusmerkkiä (==) ja sijoituksessa yhtä (=) SQL-kielessä yhtäsuuruuden vertailussa käytetään kuitenkin yhtä</li></ul></li></ul><div class="language-bash"><pre><code>SELECT first_name FROM <span class="token function">users</span> WHERE first_name <span class="token operator">=</span> <span class="token string">&#39;jorma&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>eri suuri kuin != tai &lt;&gt;</li></ul><div class="language-bash"><pre><code>    SELECT first_name FROM <span class="token function">users</span> WHERE first_name <span class="token operator">!=</span> <span class="token string">&#39;jorma&#39;</span><span class="token punctuation">;</span>
    SELECT first_name FROM <span class="token function">users</span> WHERE first_name <span class="token operator">&lt;&gt;</span> <span class="token string">&#39;jorma&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>suurempi kuin (&gt;)</li><li>suurempi tai yhtä suurin kuin (&gt;=)</li><li>pienempi kuin (&lt;)</li><li>pienempi tai yhtä suuri kuin (&lt;=)</li><li>BETWEEN AND</li></ul><div class="language-bash"><pre><code>    <span class="token comment"># haetaan kaikki työntekijät employees taulusta, joiden palkka on vähintään 3000 euroa ja enintään 5000 kuukaudessa</span>
    SELECT monthly_pay FROM employees WHERE monthly_pay BETWEEN <span class="token number">3000</span> AND <span class="token number">5000</span>
    <span class="token comment"># sama kuin </span>
    SELECT monthly_pay FROM employees WHERE monthly_pay <span class="token operator">&gt;=</span> <span class="token number">3000</span> monthly_pay <span class="token operator">&lt;=</span> <span class="token number">5000</span>
</code></pre></div><ul><li>IN <ul><li>NOT IN kääntää hakuehdon</li></ul></li></ul><div class="language-bash"><pre><code>SELECT * FROM <span class="token function">users</span> WHERE <span class="token function">id</span> IN <span class="token punctuation">(</span><span class="token number">1,2</span><span class="token punctuation">)</span>
<span class="token comment"># sama kuin</span>
SELECT * FROM <span class="token function">users</span> WHERE <span class="token function">id</span> <span class="token operator">=</span> <span class="token number">1</span> OR <span class="token function">id</span> <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><ul><li><p>IS NULL</p><ul><li>IS NOT NULL kääntää hakuehdon</li><li>Oletuksena relaatiotietokannan taulujen jokainen sarake on pakollinen tarkoittaen sitä, ettei saraketta voi jättää tyhjäksi! On kuitenkin ihan tavallista, että osa tiedoista on vapaaehtoisia (eli ne voidaan jättää tyhjiksi). Relaatiotietokantataulun sarake pitää erikseen merkata nullableksi, jos sen saa jättää tyhjäksi. Kun taulun sarake jätetään tyhjäksi sen arvoksi tulee NULL</li><li>NULL arvoa ei voi verrata totuttuun tapaan yhtääsuuruus (=) / erisuuruusoperaattoreilla (!= tai &lt;&gt;) vaan sitä varten on oma vertailu IS NULL / IS NOT NULL</li></ul></li><li><p>Kuvitellaan tilanne, että koodaat sivustoa, jossa rekisteröitymislomakkeella kysytään rekisteröityvän käyttäjän siviilisäätyä (profile_information taulussa marital_status-sarake). Koska kaikki eivät halua kertoa siviilisäätyään, käyttäjälle pitää antaa mahdollisuus olla kertomatta, joten marital_status-sarake voi olla nullable, muut vaihtoehdot voivat olla married, divorced, single, not_married</p></li></ul><div class="language-bash"><pre><code><span class="token comment"># emme ole vielä käyneet SQL-kielen sisäänrakennettuja funktiota läpi, </span>
<span class="token comment"># mutta COUNT on yksi sellainen. COUNT funktio laskee sarakkeiden lukumäärän</span>
<span class="token comment"># eli tämä kysely palauttaa käyttäjien määrän, </span>
<span class="token comment"># jotka eivät ole halunneet kertoa siviilisäätyään (marital_status on NULL)</span>
SELECT COUNT<span class="token punctuation">(</span>id<span class="token punctuation">)</span> FROM profile_information WHERE marital_status IS NULL

<span class="token comment"># tämä taas palauttaa käyttäjien määrän, </span>
<span class="token comment"># jotka ovat kertoneet (voi siis olla married, divorced, single tai not_married)</span>
SELECT COUNT<span class="token punctuation">(</span>id<span class="token punctuation">)</span> FROM profile_information WHERE martial_status IS NOT NULL
</code></pre></div><h3 id="sumea-haku" tabindex="-1">SUMEA HAKU <a class="header-anchor" href="#sumea-haku" aria-hidden="true">#</a></h3><h4 id="like-ja" tabindex="-1">LIKE ja % <a class="header-anchor" href="#like-ja" aria-hidden="true">#</a></h4><ul><li>LIKE on hakuoperaattori, jota yhdessä %-merkin kanssa voidaan käyttää sumeaan hakuun</li></ul><div class="language-bash"><pre><code>    SELECT first_name FROM <span class="token function">users</span> WHERE first_name LIKE <span class="token string">&#39;j%&#39;</span>
</code></pre></div><ul><li>hae etunimi users-taulusta kaikilta joiden etunimi alkaa j:llä ja sen jälkeen voi tulla mitä tahansa kirjaimia</li></ul><div class="language-bash"><pre><code>    SELECT first_name FROM <span class="token function">users</span> WHERE first_name LIKE <span class="token string">&#39;%j%&#39;</span>
</code></pre></div><ul><li>hae etunimi users-taulusta kaikilta joiden etunimessä on j-kirjain</li></ul><h4 id="alaviiva" tabindex="-1">_ (ALAVIIVA) <a class="header-anchor" href="#alaviiva" aria-hidden="true">#</a></h4><div class="language-bash"><pre><code>    SELECT first_name FROM <span class="token function">users</span> WHERE first_name LIKE <span class="token string">&#39;_orma&#39;</span>
</code></pre></div><ul><li>kysely hakee kaikki joiden etunimi alkaa millä tahansa kirjaimella ja päättyy orma</li></ul><h3 id="joinit" tabindex="-1">JOINIT <a class="header-anchor" href="#joinit" aria-hidden="true">#</a></h3><ul><li>tähän asti olemme hakeneet tietoja vain yhdestä taulusta kerrallaan. On kuitenkin hyvin yleistä, että SELECT-kyselyyn liitetään useampia tauluja</li><li>tauluja voidaan liittää yhteen erilaisilla JOINeilla: <ul><li>INNER JOIN (tarvii käytännössä joka päivä töissä, jos tekee tietokantojen kanssa hommia)</li><li>LEFT JOIN (tätäkin tarvii käytännössä joka päivä)</li><li>RIGHT JOIN <ul><li>sama kuin LEFT JOIN, mutta taulut kyselyssä eri järjestyksessä</li><li>kaikki relaatiotietokantamoottorit eivät edes tunnista RIGHT JOIN:ia</li></ul></li><li>FULL OUTER JOIN <ul><li>en ole milloinkaan tarvinnut oikeasti töissä</li></ul></li></ul></li></ul><p>Ennen kuin perehdytään tarkemmin erilaisiin JOINeihin, katsotaan, miten eri tauluissa olevat rivit voidaan &quot;liittää toisiinsa&quot;</p><h3 id="perusavain-primary-key-ja-viiteavain-foreign-key" tabindex="-1">Perusavain (Primary Key) ja Viiteavain (Foreign Key) <a class="header-anchor" href="#perusavain-primary-key-ja-viiteavain-foreign-key" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">Git-repositorio</p><p>Hae git-repositoriosta (linkki Moodlen työtilassa) blog.sql-tiedosto ja importaa (tuo) tiedoston sisältö PHPMyAdminilla.</p></div><div class="tip custom-block"><p class="custom-block-title">VRT MongoDB</p><p>Esimerkiksi MongoDB:ssä voi tallentaa ns. nestattuja, eli sisäkkäisiä, dokumenttejä) kts. kuva.</p></div><p><img src="/assets/4.f25638da.png" alt="mysql"></p><ul><li><p>Yo. kuvassa on täysin toimiva MongoDB:n tietokantaskeema. Siinä blogipostaukseen liittyvät kommentit on tallennettu osaksi postausta. Nestatut dokumentit ovat MongoDB:ssä paljon käytettyjä, mutta relaatiotietokannoissa tällainen skeema ei ole mahdollista, koska relaatiotietokantataulut eivät tue sisäkkäisiä rivejä</p></li><li><p>Relaatiotietokannoissa toisiinsa liittyvät datat, jotka eivät kuitenkaan voi olla samassa tietokantataulussa liitetään toisiinsa perus -ja viiteavaimilla</p></li></ul><h4 id="perusavain" tabindex="-1">Perusavain <a class="header-anchor" href="#perusavain" aria-hidden="true">#</a></h4><div class="info custom-block"><p class="custom-block-title">INFO</p><p>On hyvä muistaa, että aina kun teet uuden tietokantataulun luot sille ensimmäiseksi perusavaimen</p></div><ul><li>Perusavain on sarake, joka toimii tauluin yksittäisen rivin yksilöllisenä tunnisteena (vertaa MongoDB-dokumentin _id-kenttä)</li><li>Perusavaimen tulee olla yksilöllinen</li><li>Joissakin tapauksissa voidaan käyttää ns. yhdistelmä eli komposiittiavainta perusavaimena, mutta mennään siihen myöhemmin</li><li>Perusavain voi olla myös luonnostaan yksilöllinen tunniste. Käyttäjiä tallennettaessa tällainen voisi olla vaikka henkilötunnus (ei ole olemassa kahta eri henkilö, jolla olisi sama henkilötunnus)</li><li>On kuitenkin parmpi antaa tietokannan huolehtia perusavaimista ja luoda jokaiselle taululle id-kenttä, josta tekee perusavaimen <ul><li>PHPMyAdmin-sovelluksella perusavaimen voi tehdä sarakkeesta antamalla sille tietotyypiksi INT (kokonaisluku) ja täppäämällä A_I-sarakkeen <ul><li>kun teet kokonaisluku-sarakkeesta A_I-kentän, sille tulee automaattisesti Indeksi-sarakkeeseen Primary (Primary-indeksi) tarkoittaa Perusavainta</li></ul></li></ul></li></ul><div class="info custom-block"><p class="custom-block-title">A_I</p><p>AI tulee sanoista Auto Increment ja se tarkoittaa automaattisesti kasvavaa järjestysnumeroa. Kun lisäät ensimmäisen käyttäjän, se saa id-kentän arvoksi 1, toinen saa 2 jne. Koodarin ei tarvitse itse huolehtia siitä, että järjestysnumero on oikea, vaan AI takaa sen, että päällekkäisyyksiä ei synny ikinä</p></div><p><img src="/assets/5.0066b353.png" alt="mysql"></p><ul><li>Ao kuvassa näet tuntiharjoitus1-tietokannan users-taulun rakenteen</li></ul><p><img src="/assets/6.5b0e2133.png" alt="mysql"></p><ul><li>Nimi: id <ul><li>huomaa keltainen avain kentässä: se tarkoittaa perusavainta</li></ul></li><li>Tyyppi: INT(11) 11 numeroa pitkä kokonaisluku</li><li>Tyhjä: Ei (Perusavain on aina pakollinen. Kun sarakkeen merkitsee perusavaimeksi, sitä ei voi jättää tyhjäksi)</li><li>Oletusarvo: None (Oletusarvoa ei tarvitse antaa, koska kenttä on AUTO_INCREMENT)</li><li>Lisätiedot: AUTO_INCREMENT (MySQL huolehtii sisäisesti siitä, että id-kentän arvo on aina yksilöllinen)</li></ul><h4 id="viiteavain" tabindex="-1">Viiteavain <a class="header-anchor" href="#viiteavain" aria-hidden="true">#</a></h4><p>Tehdään aiemmin näytetty blogipostauksista ja kommenteista nyt uudelleen relaatiotietokantaan sopivalla skeemalla</p><p><img src="/assets/11.bb092154.png" alt="mysql"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Koska relaatiotietokantaan ei voi tallentaa sisäkkäistä dataa, kuten aiemmin teimme MongoDB:n esimerkissä, meidän pitää luoda postauksille oma taulu (posts) ja kommenteille oma taulu (comments) Yo kuvassa näkyy viiva (relaatio) näiden kahden taulun välillä. Se on vedetty posts-tauklun id-kentästä comments-taulun post_id-kenttään</p></div><ul><li>Tässä yo. esimerkissä comments-taulun post_id-sarake on viiteavain. Tämä viiteavain viittaa posts-taulun id-sarakkeeseen, joka on perusavain.</li><li>comments-talulussa on siis oma perusavaimensa (id-sarake), comment-tekstikenttä ja post_id-sarake, joka on posts-taulun viiteavain</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Tämä on ns. one-to-many relationship (yhdestä moneen yhteys). Käytännössä se tarkoittaa sitä, että posts-taulun id-kenttä on yksilöllinen (samalla id-sarakkeen arvolla voi olla vain yksi postaus), mutta comments-taulun post_id-sarakkeessa voi olla sama posts-taulun id-kentän arvo usaeamman kerran</p><p>Suomeksi: yhdellä blogipostauksella voi olla monta kommenttia</p><p><b>Kun pääsemme suunnitteluosioon, tarkastelemme lähemmin eri relaatiomuotoja, mutta tässä vaiheessa on tärkeää ymmärtää tietokantataulujen väliset yhteydet vain kyselyjen JOINien kannalta</b></p></div><p><img src="/assets/12.bc8eafcc.png" alt="mysql"></p><p>Yo. kuvassa on on kaksi taulua vasemmalla comments-taulu ja oikealla posts-taulu. Taulujen rivit on yhdistetty nuolilla niin, että perusavaimien ja viiteavaimien väliset yhteydet näkyvät</p><ul><li><ol><li>postauksella on 2 kommenttia (kommentit 1 ja 2)</li></ol></li><li><ol start="2"><li>postauksella on 1 kommentti (kommentti 3)</li></ol></li><li><ol start="3"><li>postauksella ei ole yhtään kommenttia</li></ol></li></ul><p>Nyt takaisin JOINEIHIN</p><h3 id="inner-join" tabindex="-1">INNER JOIN <a class="header-anchor" href="#inner-join" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">Katso kuva INNER JOINista</p><p><a href="https://www.w3schools.com/sql/sql_join_inner.asp" target="_blank" rel="noopener noreferrer">https://www.w3schools.com/sql/sql_join_inner.asp</a></p></div><ul><li>INNER JOIN yhdistää kaksi eri taulua yhteen perus -ja viiteavamilla niin, että avainten täytyy täsmätä</li></ul><div class="info custom-block"><p class="custom-block-title">Suomeksi</p><p>Kun teemme kyselyn jossa haemme INNER JOINia käyttäen postaukset ja kommentit, emme näe postausta #3 ollenkaan, koska siinä ei ole yhtään kommenttia, mutta näemme postauksen #1 kahdesti, koska siinä on kaksi kommenttia</p></div><div class="language-bash"><pre><code>SELECT posts.id, posts.body, comments.comment FROM posts INNER JOIN comments ON posts.id <span class="token operator">=</span> comments.post_id
</code></pre></div><p><img src="/assets/9.56145961.png" alt="mysql"></p><h3 id="left-join" tabindex="-1">LEFT JOIN <a class="header-anchor" href="#left-join" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">Katso kuva LEFT JOINista</p><p><a href="https://www.w3schools.com/sql/sql_join_left.asp" target="_blank" rel="noopener noreferrer">https://www.w3schools.com/sql/sql_join_left.asp</a></p></div><ul><li>LEFT JOIN yhdistää kaksi eri taulua yhteen perus -ja viiteavamilla niin, että JOININ vasemmalla puolella olevasta taulusta haetaan kaikki, vaikka sitä täsmäävää viiteavainta ei olisikaan oikealla puolella olevassa taulussa</li></ul><div class="info custom-block"><p class="custom-block-title">Mikä ihmeen vasemalla puolella oleva taulu</p><p>LEFT JOINin vasemmalla puolella oleva taulu on se, joka tulee FROM:n jälkeen</p></div><p>Tehdään äskeinen kysely käyttäen INNER JOINin sijasta LEFT JOINia</p><p>Nyt näemme 4 riviä, koska niin kuin INNER JOINissakin, 1 postaus tulee kahdesti, koska siinä on kaksi kommenttia. Toinen postaus tulee kerran, koska siinä on 1 komemntti, mutta toisin kuin INNER JOINissa, nämme nyt myös postauksen #3, koska käytämme LEFT JOINia ja posts-taulu on kyselyssä JOINin vasemmalla puolella.</p><p>Huomaa, että #3 postauksen kohdalla comment-sarake näyttää NULLia</p><div class="language-bash"><pre><code>SELECT posts.id, posts.body, comments.comment FROM posts LEFT JOIN comments ON posts.id <span class="token operator">=</span> comments.post_id
</code></pre></div><p><img src="/assets/10.145c1366.png" alt="mysql"></p><h3 id="right-join" tabindex="-1">RIGHT JOIN <a class="header-anchor" href="#right-join" aria-hidden="true">#</a></h3><p>Ao. kysely palauttaa täsmälleen saman tuloksen kuin yo. LEFT JOIN-kysely, mutta taulut ovat bvain eri järjestyksessä</p><div class="language-bash"><pre><code>SELECT posts.id, posts.body, comments.comment FROM comments RIGHT JOIN posts ON posts.id <span class="token operator">=</span> comments.post_id<span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">LEFT vai RIGHT JOIN</p><p>Opettele LEFT JOIN! RIGHT JOINissa ei ole mitään muuta eroa kuin taulujen järjestys. Useimmiten näkee käytettävän LEFT JOINia eikä RIGHT JOIN edes toimi kaikissa relaatiotietokantatoteutuksissa. RIGHT JOIN ei ole pakollinen, koska sen voi aina korvata LEFT JOINilla</p></div><h3 id="full-join" tabindex="-1">FULL JOIN <a class="header-anchor" href="#full-join" aria-hidden="true">#</a></h3><ul><li>FULL JOIN hakee kaikki rivit JOINien molemmista tauluista.</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>MariaDB ja MySQL eivät tue FULL JOINia. ao. kuvan esimerkki on PostgreSQL:stä</p></div><p><img src="/assets/11.29ba4635.png" alt="postgres"></p><div class="language-bash"><pre><code>SELECT posts.id, posts.body, comments.comment FROM posts FULL JOIN comments ON posts.id <span class="token operator">=</span> comments.post_id<span class="token punctuation">;</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">FULL JOIN</p><p>En ole itse koskaan tarvinnut FULL JOINia missään softassa töissä</p></div><h3 id="joineista" tabindex="-1">JOINeista <a class="header-anchor" href="#joineista" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">INFO</p><p>JOINin jälkeen tulee taulu, joka halutaan liittää ja sen jälkeen tulee ON, jossa määritetään, minkä sarakkeiden välille yhteys (JOIN) muodostetaan</p><p><i>SELECT taulu1 INNER | LEFT JOIN taulu2 ON taulu1.sarake = taulu2.sarake</i></p></div><ul><li>Onko JOIN aina pakko tehdä perus -ja viiteavaimen välille <ul><li>Ei ole. Tietokantataulussa ei kyselyn toiminnan kannalta tarvitse edes olla perusavainta</li><li><b>Vaikka perusavainta ei tarvitse, tee se kuitenkin aina, koska sillä on vaikutusta esim. kyselyjen hakunopeuteen ja viite-eheyden automaattiseen ylläpitämiseen</b></li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Tuo / importaa git-reposta db_without_primarykeys ja suorita ao. kysely</p></div><div class="language-bash"><pre><code>SELECT * FROM <span class="token function">users</span> INNER JOIN vehicles ON users.email <span class="token operator">=</span> vehicles.email
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">Kun liitettävät sarakkeet ovat samalla nimellä, voidaan JOIN-lauseketta lyhentää</p><p>Voit käyttää JOINissa ON-avainsanan sijasta USINGia Tämä onnistuu kuitenkin vain, kun taulujen yhdistämiseen käytetyt sarakkeet ovat saman nimiset, jos sarakkeet ovat eri nimillä, pitää käyttää ON-avainsanaa</p></div><div class="language-bash"><pre><code>SELECT * FROM <span class="token function">users</span> INNER JOIN vehicles USING<span class="token punctuation">(</span>email<span class="token punctuation">)</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>yo. kyselyssä liitetään JOIN taulujen email-sarakkeisiin. email voi toimia yksilöllisenä tunnisteena, koska yksi sähköpostiosoite voi olla vain yhdellä ihmisellä kerrallaan. Perus -/ viiteavaimia ei siis tarvita joinien tekemiseen. Riittää, että sarakkeissa on samat arvot ja kysely toimii halutulla tavalla.</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Ei ole yhtään hyvää syytä jättää perusavainta tekemättä tietokantatauluun, vaikka kyselyt voivat teknisesti toimia ilman niitä. Tee perusavain aina</p><p>Perusavaimen arvo [int(11)] ei muutu ikinä, mutta yo. esimerkissä on mahdollista, että käyttäjän sähköpostiosoite muuttuu. Sähköpostiosoitteen muuttuessa myös siihen viittaavat rivit muissa tietokantatauluissa täytyy päivittää, tai liitos katoaa.</p></div><h3 id="alias-as" tabindex="-1">ALIAS (AS) <a class="header-anchor" href="#alias-as" aria-hidden="true">#</a></h3><ul><li>Kun käytät INNER / LEFT JOINeja ja liität useampia tauluja yhteen, voi olla, että tauluissa on päällekkäisiä sarakkeiden nimiä</li></ul><div class="language-bash"><pre><code>
<span class="token comment"># esimerkiksi tämä ao. kysely antaa virheilmoituksen Column `id` in WHERE clause is ambiguous</span>

SELECT posts.* FROM posts INNER JOIN comments ON posts.id <span class="token operator">=</span> comments.post_id WHERE <span class="token function">id</span> <span class="token operator">=</span> <span class="token number">1</span>

</code></pre></div><ul><li><p>Tämä siis tarkoittaa sitä, että WHERE-lausekkeen ehdossa käytetty id-sarake on molemmissa tauluissa (sekä posts että comments, eikä MySQL tiedä, kumman taulun id-sarakkeestä on kyse)</p></li><li><p>Käytä aina taulun nimeä sarakkeen edessä</p></li></ul><div class="language-bash"><pre><code>SELECT posts.* FROM posts INNER JOIN comments ON posts.id <span class="token operator">=</span> comments.post_id WHERE posts.id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">Alias</p><p>Joskus taulujen ja / tai sarakkeiden nimet voivat olla aika pitkiäkin ja silloin on hyvä käyttää AS-avainsanaa antamaan alias tauluille</p></div><div class="language-bash"><pre><code>SELECT p.* FROM posts AS p INNER JOIN comments AS c ON p.id <span class="token operator">=</span> c.post_id WHERE p.id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>Yo. esimerkissä posts-taululla on alias p ja comments-taululla c Täydet taulujen nimet piti kirjoittaa vain yhden kerran</li></ul><h3 id="self-join" tabindex="-1">SELF JOIN <a class="header-anchor" href="#self-join" aria-hidden="true">#</a></h3><ul><li>SELF JOIN ei ole mikään kolmas JOIN-tyyppi INNERin ja LEFTin lisäksi vaan sillä tarkoitetaan sitä, kun tehdään kysely yhteen tauluun kahdella eri nimellä käyttäen aliaksia</li></ul><div class="tip custom-block"><p class="custom-block-title">Git-reposta</p><p>Tuo tiedot git-repositorion selfjoin (1).sql-tiedostosta</p></div><p>Haetaan kaikki tiedot asiakkaista, niiltä paikkakunnilta joista on kotoisin vähintään 2 asiakasta</p><div class="language-bash"><pre><code>SELECT * FROM customers AS c1, customers AS c2 WHERE c1.id <span class="token operator">&lt;&gt;</span> c2.id AND c1.city <span class="token operator">=</span> c2.city<span class="token punctuation">;</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>yo. kyselyssä on SELF JOIN, eli teemme kyselyn kahdella eri aliaksella yhteen ja samaan tauluun, jotta voimme tehdä taulun sisällä vertailuja</p></div><h3 id="tehtavat-1-palautettava" tabindex="-1">Tehtävät 1 (palautettava) <a class="header-anchor" href="#tehtavat-1-palautettava" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">Tehtävien palautus</p><p>Tehtävät pitää palauttaa Moodlen palautuslaatikkoon nimeltä Tehtävät 1 Palauta yksi (1) txt-tiedosto (huom. ei doc / docx tms.), vaan esim. tehtavat1.txt jossa jokainen vastaus on omalla rivillään ao. kuvatussa muodossa</p><p>1.1 SELECT ....;<br> 1.2 SELECT ....;<br> 1.3 SELECT ....;<br></p><p><b>Älä palauta tulosta, koska tulos voi vaihdella, palauta ainoastaan tekemäsi kyselyt yo. muodossa</b></p><ul><li>Saat jokaisesta kyselystä 1. pisteen, jos se on oikein. Vääristä tuloksista saa 0 pistettä.</li><li>Jos palautus ei ole txt-tiedostossa tai vastaukset ovat väärässä formaatissa, tehtäviä ei arvioida ollenkaan</li></ul></div><ul><li>1.1. Tee kysely, joka listaa kaikki työntekijät</li><li>1.2. Tee kysely, joka listaa kaikki osastot</li><li>1.3 Hae 10. työntekijä (voit katsoa 10. id:n arvon ja käyttää id:tä haussa)</li><li>1.4 Hae viimeisen osaston tiedot (ei tarvitse työntekijöitä) (Voit katsoa viimeisen osaston id-sarakkeen arvon ja käyttää sitä rajaamaan hakua)</li><li>1.5 Tee kysely, jolla selvität, mikä on 20. työntekijän palkka ja etunimi (voit katsoa 20. työntekijän id:n arvon ja käyttää sitä rajaamaan hakua)</li><li>1.6 Tee kysely, jolla selvität, mikä department_id on 12. työntekijällä (hae työntekijän id:llä) (tarkoituksena hakea siis pelkästään department_id-sarakkeen arvo)</li><li>1.7 Tee kysely, joka listaa kaikki työntekijät, joiden sukunimi on kuru</li><li>1.8 Tee kysely, jolla haet departmentin (id 3) kaikki työntekijät <ul><li>tee kysely pelkästään employees-tauluun käyttäen department_id:tä</li></ul></li><li>1.9 Muokkaa ylempää kyselyä niin, että teet INNER JOINin ja käytät nyt WHERE-lausekkeessa ehtona departments.id-saraketta</li></ul><p>Voit saada tästä tehtäväpaketista yhteensä 9 pistettä, jos kaikki kyselyt ovat oikein</p><h3 id="koostefunktiot-aggregate-functions" tabindex="-1">KOOSTEFUNKTIOT (AGGREGATE FUNCTIONS) <a class="header-anchor" href="#koostefunktiot-aggregate-functions" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Koostefunktiot koostavat nimensä mukaisesti monesta arvosta yhden arvon.</p><p>Esimerkiksi AVG()-funktio laskee keskiarvon. Jos ajattelet, miten esimerkiksi todistuksen keskiarvo lasketaan: Laske yhteen kaikkien opintojaksojen arvosanat ja jaa se opintojaksojen lukumäärällä. AVG siis koostaa useasta arvosanasta yhden luvun</p></div><div class="tip custom-block"><p class="custom-block-title">Importaa git-reoposta tiedonhallinta_harjoius.sql</p><p>Jos sinulla ei vielä ole tiedonhallinta_harjoitus-tietokantaa, importaa se nyt</p></div><div class="tip custom-block"><p class="custom-block-title">Koostefunktioiden kanssa kannattaa käyttää aliasta sarakkeiden nimissä</p><p>Koostefunktioita käytettäessä tuloksessa sarakkeen nimeksi tulee oletuksena käytetty koostefunktio ja funktion argumenttina käytetty sarake. Aliaksien käyttö parantaa luettavuutta</p></div><div class="info custom-block"><p class="custom-block-title">Koostefunktiot ja WHERE</p><p><b>WHERE-lauseke toimii koostefunktioiden kanssa niin kuin normaaleissakin SELECT-lauseissa. Voit siis rajata WHEREa käyttämällä tulosjoukkoa, johon koostefunktio kohdistuu</b></p><p>HUOM! Et kuitenkaan voi käyttää WHERE-lausekkeessa koostefunktiota</p><p>ao. kysely ei toimi</p><p>SELECT AVG(salary) FROM <code>employees</code> WHERE avg(salary) &gt; 3000 GROUP BY department_id</p><p>koska siinä on WHEREssä AVG-funktio</p><p>GROUP BYsta voit lukea tarkemmin täältä kohdasta <a href="#koostefunktiot-ja-group-by">KOOSTEFUNKTIOT JA GROUP BY</a></p><p>Lisätietoja siitä, miten yo. esimerkin kysely saadaan toimimaan, voit lukea täältä kohdasta <a href="#koostefunktiot-ja-having">HAVING</a></p><p>Jos tarvitset koostefunktion tulosta rajaavana ehtona jossakin kyselyssä voit tehdä sen <a href="#alikysely-subquery">alikyselyllä.</a></p></div><h4 id="avg" tabindex="-1">AVG <a class="header-anchor" href="#avg" aria-hidden="true">#</a></h4><ul><li>Lasketaan kaikkien työntekijöiden keskiarvopalkka</li></ul><div class="language-bash"><pre><code>SELECT AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS avg_salary FROM employees
</code></pre></div><h4 id="sum" tabindex="-1">SUM <a class="header-anchor" href="#sum" aria-hidden="true">#</a></h4><ul><li>Lasketaan kaikkien työntekijöiden palkat yhteen</li></ul><div class="language-bash"><pre><code>SELECT SUM<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS sum_salary FROM employees
</code></pre></div><h4 id="min-max" tabindex="-1">MIN / MAX <a class="header-anchor" href="#min-max" aria-hidden="true">#</a></h4><ul><li>Haetaan kaikkien työntekijöiden joukosta pienin ja isoin palkka</li></ul><div class="language-bash"><pre><code>SELECT MIN<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS min_salary, MAX<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS max_salary FROM employees
</code></pre></div><ul><li>Lasketaan pienin ja suurin palkka ainoastaan työntekijöiltä, joiden department_id = 2</li></ul><div class="language-bash"><pre><code>    SELECT MIN<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS min_salary, MAX<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS max_salary FROM employees WHERE department_id <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><h4 id="count" tabindex="-1">COUNT <a class="header-anchor" href="#count" aria-hidden="true">#</a></h4><ul><li>Lasketaan kaikki työntekijät</li></ul><div class="language-bash"><pre><code>SELECT COUNT<span class="token punctuation">(</span>id<span class="token punctuation">)</span> AS num_of_employees FROM employees
</code></pre></div><ul><li>Lasketaan department_id 2 työskentelevät työntekijät</li></ul><div class="language-bash"><pre><code>SELECT COUNT<span class="token punctuation">(</span>id<span class="token punctuation">)</span> FROM employees WHERE department_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="koostefunktiot-ja-group-by" tabindex="-1">KOOSTEFUNKTIOT JA GROUP BY <a class="header-anchor" href="#koostefunktiot-ja-group-by" aria-hidden="true">#</a></h3><ul><li>Koostefunktiot palauttavat oletuksena yhden luvun, mutta tätä oletustoimintatapaa voi muuttaa käyttämällä koostefunktiota yhessä GROUP BY:n kanssa.</li></ul><div class="info custom-block"><p class="custom-block-title">Voit käyttää GROUP BY:ta näin</p><p>SELECT COUNT(id) FROM table GROUP BY column</p><p>column on mikä tahansa taulussa oleva sarakkeen nimi</p></div><div class="language-bash"><pre><code><span class="token comment"># ao. kysely laskee kaikkien työntekijöiden sijaan työntekijät osastokohtaisesti</span>
SELECT department_id, COUNT<span class="token punctuation">(</span>id<span class="token punctuation">)</span> AS num_of_emp FROM employees GROUP BY department_id<span class="token punctuation">;</span>
</code></pre></div><p><img src="/assets/15.3602ef5d.png" alt="mysql"></p><ul><li>Yo. kuvassa näkyy työntekijöiden lukumäärä osastoittain, koska käytimme GROUP BYssa department_id-saraketta. Saimme siis yhden luvun sijasta luvun jokaiselle osastolle</li><li>Kun kaikkien osastojen työntekijöiden lukumäärä lasketaan yhteen, saamme tulokseksi 99, joka on kaikkien työntekijöiden lukumäärä</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>GROUP BY luo jokaiselle GROUP BYssa käytetylle sarakkeen arvolle oman &#39;ämpärin&#39;, johon rivit lajitellaan. Sitten koostefunktio suoritetaan jokaiselle ämpärille erikseen</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><pre><code>Kyselyn GROUP BY:ssa voi käyttää useampaa saraketta
</code></pre></div><div class="language-bash"><pre><code>    SELECT AVG<span class="token punctuation">(</span>credits<span class="token punctuation">)</span> FROM courses GROUP BY name, year
</code></pre></div><h3 id="koostefunktiot-ja-having" tabindex="-1">KOOSTEFUNKTIOT JA HAVING <a class="header-anchor" href="#koostefunktiot-ja-having" aria-hidden="true">#</a></h3><ul><li>Tehdään kysely, jolla saat listattua kaikkien osastojen keskiarvopalkat, jos ne ylittävät 4200</li></ul><div class="language-bash"><pre><code>SELECT department_id, AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS avg_salary FROM employees GROUP BY department_id HAVING AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span><span class="token punctuation">;</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>HAVING-lausekkeessa voit käyttää koostefunktiota rajaavana ehtona ja HAVING kohdistuu GROUP BY:n &#39;ämpäreihin&#39;</p></div><h3 id="skalaarifunktiot-scalar-functions" tabindex="-1">SKALAARIFUNKTIOT (SCALAR FUNCTIONS) <a class="header-anchor" href="#skalaarifunktiot-scalar-functions" aria-hidden="true">#</a></h3><p>Skalaarifunktion voit suorittaa rivikohtaisesti. Koostefunktiot hävittävät ne yksittäiset rivit, joista koostefunktion tulos koostuu, mutta skalaarifunktion tulos suoritetaan jokaiselle tulosjoukon riville</p><h4 id="concat" tabindex="-1">CONCAT <a class="header-anchor" href="#concat" aria-hidden="true">#</a></h4><ul><li>CONCAT yhdistää kaksi merkkijonoa</li></ul><div class="language-bash"><pre><code>SELECT CONCAT<span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span>, <span class="token string">&#39;world&#39;</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="upper" tabindex="-1">UPPER <a class="header-anchor" href="#upper" aria-hidden="true">#</a></h4><ul><li>UPPER muuttaa kirjaimet isoiksi</li></ul><div class="language-bash"><pre><code>SELECT UPPER<span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="lower" tabindex="-1">LOWER <a class="header-anchor" href="#lower" aria-hidden="true">#</a></h4><ul><li><p>LOWER muuttaa kirjaimet pieniksi</p><div class="language-bash"><pre><code>SELECT LOWER<span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
</code></pre></div></li></ul><h4 id="now" tabindex="-1">NOW <a class="header-anchor" href="#now" aria-hidden="true">#</a></h4><ul><li>NOW palauttaa suoritushetken aikaleiman</li></ul><div class="language-bash"><pre><code>SELECT NOW<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="timestampdiff" tabindex="-1">TIMESTAMPDIFF <a class="header-anchor" href="#timestampdiff" aria-hidden="true">#</a></h4><ul><li>Laskee kahden päivämäärän erotuksen annettuna unitteina</li></ul><div class="info custom-block"><p class="custom-block-title">TIMESTAMPDIFF</p><p>TIMESTAMPDIFF(unit, date1, date2)</p></div><p>`</p><div class="language-bash"><pre><code>SELECT TIMESTAMPDIFF<span class="token punctuation">(</span>HOUR,<span class="token string">&#39;2022-02-01&#39;</span>,<span class="token string">&#39;2022-02-21&#39;</span><span class="token punctuation">)</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">Henkilön iän laskeminen</p><p>Ikä on sellainen tieto, jota ei kannata tallentaa teitokantatauluun kokonaislukuna, koska se muuttuu koko ajan. Kannattaa ennemmin tallentaa syntymäpäivä joko DATE, DATETIME tai TIMESTAMPP-tyyppiseen sarakkeeseen ja laskea ikä siitä käyttäen TIMESTAMPDIFFiä ja NOW-funktiota</p></div><h3 id="order-by" tabindex="-1">ORDER BY <a class="header-anchor" href="#order-by" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">INFO</p><p>ORDER BY-lausekkeella voit vaihtaa tulosjoukon järjestystä Tämä on hyödyllistä esim. juuri koostefunktioiden tulosten listauksessa, koska koostefunktiot hävittävät yksittäisten rivien id-kentät</p><p>ORDER BY toimii näin: ORDER BY column1, column2 ASC | DESC</p></div><ul><li>Tehdään yo. kysely, jossa haettiin kaikki osastot, joiden keskipalkka on yli 4200 niin, että järjestetään tulos keskiarvopalkan mukaan</li></ul><div class="language-bash"><pre><code><span class="token comment"># oletuksena suunta on ASC eli nouseva, jos sitä ei erikseen määritetä</span>
<span class="token comment"># nouseva tarkoittaa sitä, että pienin palkka on ylimpänä ja suurin alimpana</span>
<span class="token comment"># ao. kysely:</span>
SELECT department_id, AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS avg_salary FROM employees GROUP BY department_id HAVING AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span> ORDER BY avg_salary

<span class="token comment"># on siis sama kuin tämä</span>
SELECT department_id, AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS avg_salary FROM employees GROUP BY department_id HAVING AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span> ORDER BY avg_salary ASC

<span class="token comment"># vaihdetaan suunta laskevaksi, eli niin, että suurin palkka on ylhäällä ja pienin alhaalla</span>
SELECT department_id, AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> AS avg_salary FROM employees GROUP BY department_id HAVING AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4200</span> ORDER BY avg_salary DESC
</code></pre></div><h3 id="insert" tabindex="-1">INSERT <a class="header-anchor" href="#insert" aria-hidden="true">#</a></h3><ul><li>INSERT-lauseke lisää tietokantatauluun rivin</li></ul><p><img src="/assets/12.3aa800bc.png" alt="mysql"></p><ul><li><p>Huomaa, että users-taulussa on oikeasti 3 saraketta</p><ul><li>id (kokonaisluku)</li><li>first_name (merkkijono)</li><li>last_name (merkkijono)</li></ul></li><li><p>insertistä kuitenkin puuttuu id-sarake. Sitä ei tarvitse erikseen merkata, koska id on AUTO_INCREMENT-sarake, joten se lisätään automaattisesti</p></li></ul><h3 id="delete" tabindex="-1">DELETE <a class="header-anchor" href="#delete" aria-hidden="true">#</a></h3><ul><li>DELETE-lauseke poistaa tietokantataulusta rivin / useita rivejä <ul><li>DELETE-lausekkeen rajaava ehto (WHERE määrää sen kuinka monta riviä poistetaan. Jos se jätetään pois, poistetaan taulusta kaikki rivit)</li></ul></li></ul><p><img src="/assets/13.0b6ff540.png" alt="mysql"></p><h3 id="update" tabindex="-1">UPDATE <a class="header-anchor" href="#update" aria-hidden="true">#</a></h3><ul><li>UPDATE lauseke päivittää olemassa olevan rivin / useita rivejä tietokannasta annetuilla ehdoilla</li></ul><p><img src="/assets/16.95acb94d.png" alt="mysql"></p><h3 id="alikysely-subquery" tabindex="-1">ALIKYSELY (SUBQUERY) <a class="header-anchor" href="#alikysely-subquery" aria-hidden="true">#</a></h3><p>Alikyselyllä tarkoitetaan kyselyä, joka on toisen kyselyn sisällä. On suositeltavaa käyttää JOINeja alikyselyjen sijasta silloin, kun se on mahdollista.</p><ul><li>Tarvitset alikyselyä esim. silloin, kun tarvitset rajaavana WHERE-ehdossa jonkun koostefunktion tuloksen</li></ul><div class="language-bash"><pre><code>    SELECT first_name FROM employees WHERE salary <span class="token operator">&gt;</span> <span class="token punctuation">(</span>SELECT AVG<span class="token punctuation">(</span>salary<span class="token punctuation">)</span> FROM employees<span class="token punctuation">)</span>
</code></pre></div><h3 id="tehtavat-2-palautettava" tabindex="-1">TEHTÄVÄT 2 (palautettava) <a class="header-anchor" href="#tehtavat-2-palautettava" aria-hidden="true">#</a></h3><div class="info custom-block"><p class="custom-block-title">Tietokanta</p><p>Harjoitukset tehdään tiedonhallinta_harjoitus2-tietokantaan Hae se git-repositoriosta ja tuo PHPMyAdminiin</p></div><ul><li><p>2.1 Tee kysely, jolla lasket keskiarvopalkan</p><ul><li>Tuloksena yksi rivi, yksi sarake</li></ul></li><li><p>2.2. Tee kysely, jolla haet pienimmän palkan</p><ul><li>Tuloksena yksi rivi, yksi sarake</li></ul></li><li><p>2.3 Tee kysely, jolla haet suurimman palkan</p><ul><li>Tuloksena yksi rivi, yksi sarake</li></ul></li><li><p>2.4 Tee kysely, jolla haet suurimman palkan sovelluskehitys-osastolta.</p><ul><li>Kyselyssä pitää käyttää INNER JOINia ja osaston nimeä hakuehdossa</li><li>Tuloksena riittää yksi rivi, yksi sarake</li></ul></li><li><p>2.5 Tee kysely, jolla haet pienimmän palkan palkat-osastolta</p><ul><li>Kyselyssä pitää käyttää INNER JOINia ja osaston nimeä hakuehdossa</li><li>Tuloksena riittää yksi rivi, yksi sarake</li></ul></li><li><p>2.6 Tee kysely, jolla haet keskiarvotpalkat osastoittain</p><ul><li>Tuloksena riittää yksi sarake</li></ul></li><li><p>2.7 Tee INSERT-kysely, jolla lisäät uuden osaston</p><ul><li>Osaston nimi pitää olla <i>TK-osasto</i></li></ul></li><li><p>2.8 Tee kysely, jolla haet kaikkien työntekijöiden etu -ja sukunimet sekä osaston nimen jolla he työskentelevät</p><ul><li>Käytä tässä INNER JOINia</li><li>Tuloksen sarakkeet: employees.first_name, employees.last_name ja <a href="http://departments.name" target="_blank" rel="noopener noreferrer">departments.name</a></li></ul></li><li><p>2.9 Tee kysely, jolla haet niiden osastojen nimet, joilla ei työskentele ketään</p><ul><li>Ainoa osasto, jolla ei työskentele ketään on 2.7 tehtävässä lisätty TK-osasto</li><li>Tämän voit tehdä käyttäen LEFT JOInia employees ja departments-taulujen välillä</li><li>Käytä rajaavana hakuehtona IS-filteriä</li><li>Tuloksena riittää yksi rivi, yksi sarake (name)</li></ul></li><li><p>2.10 Tee kysely, jolla haet niiden osastojen keskiarvopalkat, joiden keskiarvopalkka on yli 3500</p><ul><li>Tuloksena riittää yksi sarake (keskiarvopalkka)</li></ul></li><li><p>2.11 Tee kysely, jolla haet työntekijöiden lukumäärän osastoittain</p><ul><li>Tuloksena riittää yksi sarake (työntekijöiden lukumäärä)</li></ul></li><li><p>2.12 Tee kysely, jolla haet kaikki ne työntekijät,joiden palkka on alle keskiarvopalkan</p><ul><li>Käytä alikyselyä</li><li>Tulokseen voi hakea kaikki employees-taulun sarakkeet</li></ul></li><li><p>2.13 Tee kysely, jolla haet kaikki työntekjät, joiden palkka on alle oman osaston keskiarvopalkan</p><ul><li>Käytä alikyselyä</li><li>Tulokseen voi hakea kaikki employees-taulun sarakkeet</li></ul></li><li><p>2.14 Tee kysely, jolla haet työntekijän palkan ja listaat viereen keskiarvopalkan</p><ul><li>Tulokseen riittää kaksi saraketta per rivi</li></ul></li><li><p>2.15 Tee kysely, jolla haet työntekijän palkan ja listaat viereen hänen osastonsa alimman palkan</p><ul><li>Tulokseen riittää kaksi saraketta per rivi</li></ul></li></ul><h2 id="tehtavat-3-palautettava" tabindex="-1">TEHTÄVÄT 3 (palautettava) <a class="header-anchor" href="#tehtavat-3-palautettava" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">Tietokanta</p><p>Harjoitukset tehdään tiedonhallinta_harjoitus2-tietokantaan Hae se git-repositoriosta ja tuo PHPMyAdminiin</p><p>Palauta tehtävät tässä muodossa</p><ul><li><p>3.1 SELECT....;</p></li><li><p>3.2 SELECT ....;</p></li><li><p>palauta vain yksi vastaus / kysymys</p></li><li><p>älä käytä vastauksen edessä viivaa (-)</p></li><li><p>älä laita kysymystä mukaan vastaukseen. Tiedän, mitä missäkin tehtävässä halutaan</p></li></ul><p>Ole tarkkana, että palautat vain ne tiedot, joita pyydetään. Jos haettavia sarakkeita ei erikseen mainita, voit palauttaa kaikki (*)</p><p>Jokainen väärin muotoiltu vastaus arvioidaan vääränä</p><p>Tästä paketista on jaossa enintään 9 pistettä. Oikein tehdystä kyselystä saa 1 pisteen, muuten 0</p></div><ul><li><p>3.1 Tee kysely, joka laskee jokaisen työntekijän iän (voit käyttää sarakkeesta aliasta age) date_of_birth-sarakkeen perusteella</p><ul><li>listaa työntekijästä kaikki tiedot employees.* ja lisäksi vielä age-sarake</li></ul></li><li><p>3.2 Tee kysely, jolla lasket keskiarvoiän kaikista employees-taulun riveistä</p></li></ul><ul><li>yksi rivi ja sarake riittää</li></ul><ul><li><p>3.3 Tee kysely, jolla haet nuorimman työntekijän</p><ul><li>yksi rivi ja sarake riittää</li></ul></li><li><p>3.4 Tee kysely, jolla haet vanhimman työntekijän</p><ul><li>yksi rivi ja sarake riittää</li></ul></li><li><p>3.5 Tee kysely, jolla haet nuorimmat työntekijät osastoittain</p><ul><li>yksi sarake riittää</li><li>rivejä on yhtä monta kuin osastoakin</li></ul></li><li><p>3.6 Tee kysely, jolla haet työntekijöiden lukumäärän ikien mukaan ryhmiteltynä</p><ul><li>sarakkeet <ul><li>count (lukumäärä)</li><li>age (ikä)</li></ul></li></ul><p>Tässä esimerkki siitä, miltä tulos näyttää:</p><p><img src="data:image/png;base64,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" alt="mysql"></p></li><li><p>3.7 Tee kysely, jolla haet, 30-vuotiaiden lukumäärän palkat-osastolla</p><ul><li>tuloksena yksi rivi, 3 saraketta <ul><li><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL8AAAA1CAYAAAAQwTq4AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAtBSURBVHhe7ZxtU1TJFcfvd/GrzJeI2WwqWLW+ibzaVGJtsGIt+k7DUDFbiQuKSbSkUBkFsXTLh90EVx5mFNEFBFmWMBCElYEdFHQ46XO6z73d9/YMwwg7d5g+Vb+603364dzT/9u3B0EPnDmrU/MKhQJsbW2Bu8b/iobXWqHa8cr5MXd2vPfv34OjNkCz1ceVaseLZhM9421sbICjNkCz1ceVaseLZhM947158wbevn0L7hr/Kxpea4Vqx4tmEz3j5fN5cNQGaLb6uFLteNFsome8tbU1cNQGaLb6uFLteNFsome8lZUVyOVyYLsyzh8PP5peH3eqHS+aTfSM9/r1a3DUBmi2+qoyeQ0+/uLfVl+140WziZ7xlpaWwFEboNnqq8b4VfjVweNwoG3A6q92vGg20TPe4uIiMN91nYYD4maauq7Im0KOXoHv/DbPoe2oqidOQ9tYib4H2+DuN23qs8AYaxHunuF2UZ8jCpqtnnPPNH2j+cf09RCceRD1+XUPoAnLvBa+/4q27rzmqq1PWzCuoli8i7omED0mY9zT0HRG6cq/p5AGjb4maDbRM978/DwsLCwAXl/2JuWAXw4A/vvY4i1Z/tMD6f+KxHoB0jRsGk5i28+64Jnor/fd0voe+GMPYBhc/nXnKM135y84VhI6KUY11pn7NA/H467mFQ2vOqOdUhwnR8gN6XbM62k4+0z4n3XBR5jXdrlifp6PdsEo9p++AQ1Y/vJbNd630IzlYzfgpe4/eB4ekSBuwiEs/+2eaLsO77hM47/zY2LQwnUc06Fb0s+6+Oy+9Ju6GJbxCJoH0T8KZ0n4SoNq/o+EpiLzCNBsome8bDYLzJQS8MlMnsq5dAeVG64/pXL+HQ73X/in/uSJRE1pfQ/dnDb6Hur7AXL6WL2Twn8PjlPfXpjL4dx5GKRFOwd3RFuOx2GCZtY9hY4mzNsFGMzLOrlGBdgQeX3a3SJ8Qkjzcj0xz1kSWwt0jIryy0D80h+IH9fU97cPQR7LuQE4geWm6/BU9/v9TaLxCnIbtLEW0u2kB6Z5EP1RXch4lX+0G36Dfj+eH+DyMVFu6pbxhECziZ7xZmdngZnsURMNqLoBJdieF1S+1aqCbcPnTu0iIlGTWt8TwyvWvmb5of9Em7TAP0bU3I4IaGbdf+BzzNuxHvjeqJd8fRZzmoSLk0Edr9Pn/aI8yeJ9qPxqXdSa7txvEo1XMNIJv8Q+Yq1xd+ednzQ3kpLjie8QK6q9oUmeL8J5+FqfQ4FmEz3jzczMADN5gydSdSzYGxOi/JV6Km/C4uaaKGuJ2LZvuMx9xVgUIlsB3vyo+jsioJl1U3AJdz5cfKNeMk1v4yT860VQJ9cpCZe+F+UXgXil31zTnftNovHOQOYqvo3wmCbX2tDNj4/UmyUFGdXe8PN8/jGObRPWtDkYNJvoGW96ehqYCZ7okap7xIIdE2V14yLR94Vv+OKfyYeJmNi2b7i8BgN0zGmBc2lsfxv+gGP9/jIMY1uHFTSzbhlm+2Tej9+RdcMXT4nyKfiryOvybK88k39xW7W/DcewLI4Vs8uivByIjfJ+5xyNxWs6PRGIW/YPxE9+7u/7TaLxBjppSA2LsopHIHUT1YXhX56RxxxxPO7F8dKX4SD6k3x/Jmg20TPe1NQUMOO+gFWdJtipqVXYHLlAZUkHnKRAz8O9bftGy6ub/OWMEV9iCuuwhG0dVtDCdUvrheCHCwrcVdeXhH9pHQr8pZTBXdPP8yrMaX1/kepRR9nrMI7+8etK/P1qvn4lfuUX/aVYkVOqTYA93jnoJAFLGtovUHwNqSHyr26q4zRxDi7xsYh0tQTrhXmjvzyJrBpzMGg20TPexMQEMK9EItE2cqpOfDlBK6y/MsrS8Dfn5DW3g75+WWAMp8ZhnyMKmq2ec8/mrwGymKcvmL5t5Ir2LaznxSrghzy80vv6fXKmXxCsYcEfk0EL101MvIK8FlBBiAiLgS7UHGQbMEObqvje8tLeX48lDLktome8sbExGB8fB7wyrhzPMppeH3d2Hu9DaP2d3NE/vSnr7v4dyx3Q/79w2+1Bs4me8Z4/fw6O2gDNVh9Xdh7vAvw0Hzqm4Y9qF9/Ca2v70qDZRM94o6Oj4KgN0Gz1caWieOd/Avk3WGzvxQNhaVcGaDbRM96TJ0/AURug2erjSrXjRbOJnvEymQw8fvwY3DX+VzS81grVjhfNJnrGGx4eBkdtgGarjyvVjhfNJnrGs1U6HPWAE7+jbnHid9QtTvyOusWJ31G3GOJPtyQg0ZI2Gnw4Weg+koDGq9moL9sNjYlG6M6Kz4OtkEi0QjrcZo+o/F61+9Hj1z9b++0xNP/Pl7/KSUMyIXLPHOmGOc1P6+L79zafpviTYsJkxmjw4ZQQ/3xKCmZefA6Jf+5qoxTnDhaV+hjJxETLBGJS9Rgqv1ftfvT49c/WfgG7vslQjlAs8Rc/5e6a/BNDgHlIiTLnQq5fStQq7zVR3sN7qq748Y99hdH/QhwSv6gi89uo+lJkVfKyfp3qKwajYeh/O5bsuvj1e4n0MdnNPJNghPBbkz/vm7NSwuuQRYGLNcMNi9ec13qL87tHu79F/ClaXOtrx99hQj71yk+2yIUg/J0tJH4SeQKSg0E/Gid87Ck2l8B4NfJOr8Y16sJttd1223vVxxMED28R8ev3UiIfLFa9rtS9bkd2MCN3yqHaEH+Y6IalsYO3aSVExY+TLdADCBks+0KSZ7XWIekzkk1BirZiNyNbkGUSuC4WJXBqhU+/fnOG+M25jNcfttNejRgjjS12DWqnfLh7mK/RDLSKMVnE299rI6SUzxRWEfFHPtvzgbsbzaV8Je+1DHA82imN/NUKabkm4hhke7PTGuGDob0pdhPrsYdf3fxKoqeSRceBbMnzWisKXC08ikX6pNDIx2I5IhcVl9y/0WLiV58zaq4tfTzy8djCh4rheI1dRM3rJ5YfDinwkveqHZfQJ3frnYq/WD6CuclX6l5pvjLR81cTyDwamtKQOZc5tD0Yu0HJM78uJuN1rRERAfWNih9vpJFFo8YvJn7esYNXoTYeqp124iAG+YYJi1/uKrqIdH+pew1ilvCDu1Px2/Nhzl3yXv26Mqgp8WvCx00m5DeEb3kwdouyxb+FyVXBGobBlSF++oZPr3/Rjs+0RcRPcxkLGRIEbffS9GOCKWD5ZtIftrLFr+ZXh5YKjz3F8mHOve29lktknLiihC/uH80ufHVC2EPhI2WLP/zq5i9ptOuWI34UixCtfvQoJv7wXH5CRDLkThl8oeWHEmM0xS/K+lyh8+X24hdx0UOqFssX1u6Kv9S9yr5lUiPipx9AiDzjJhrxq7zv5VFHp3zx4zlYfXHzjwO4m5e786sdmM+0EfEYixeeK0iImE5+YbT5aDysk+NE2uJuo0RV+kFXP39W43cPqTi1h+FDxL/FxzZ6MIvfK8dWFjUifsyDvx4+Mm5aE4ufj7W7jSF+Pk34ZVXhLwQ3YFNC4vrgNSXL7Ce3zaf322Yu/RUYcgU+zcHjhNuGx/DLqsLWz/epeaiIn/X6Yp9FIZwP9qPRfFoZLei3A3jOcH3MKGYYd1FvJfkoA0P8Dkc94cTvqFuc+B11ixO/o25x4nfULU78jrrF+C/KHY79hE3wOk78jn2LTfA6TvyOfYtN8DpO/I59i03wOk78jn2LTfA6uyP+oXY4nDgM7UOhz7a2jr2B8n4C+my+WNEHJ/RfXPukHQY1f1+z5vtAHdkEr7M74h/rot9i7BoLfba1LYZ7aCqHcodiaYF+mz9GtH+SgCP428Bk6rdnm/vIN9h2GBK/Df5mRP6tRuUPtE3wAVvwfwl2XkHe4HYmAAAAAElFTkSuQmCC" alt="mysql"></li></ul></li><li>käytä rajaavina ehtoina osaston nimeä <a href="http://departments.name" target="_blank" rel="noopener noreferrer">departments.name</a> ja age-aliasta (age lasketaan date_of_birth-sarakkeen arvosta)</li><li>departments-taulun yhdistämiseen tarvitset INNER JOINia</li><li>koska age on funktion tulos, siinä pitää käyttää HAVING-lauseketta</li><li>group by:ssa riittää pelkkä age, koska WHERE:ssa rajataan jo muut osastot pois</li></ul></li><li><p>3.8 Tee kysely, jolla päivität 2.7 tehtävässä lisätyn TK-osaston nimen TKI-osastoksi * käytä rajaavana ehtona name-saraketta * idtä ei tarvitse käyttää, koska name-sarake on yksilöllinen (UNIQUE)</p></li><li><p>3.9 Tee kysely, jolla poistat TKI-osaston</p><ul><li>käytä poistossa rajaavana ehtona name-saraketta.</li></ul></li></ul></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"db_index.md\":\"e67c3763\",\"design_index.md\":\"56f95915\",\"dw_index.md\":\"280d61c1\",\"index.md\":\"9a948b4d\",\"info_index.md\":\"30a03c4c\",\"mysql_index.md\":\"56cbdcfa\",\"nosql_index.md\":\"eb3fa141\",\"softwares_index.md\":\"f8ddc9c2\",\"sql_index.md\":\"10401e44\"}")</script>
    <script type="module" async src="/assets/app.6b6d40d7.js"></script>
    
  </body>
</html>